<!DOCTYPE html>

<head> 
<meta charset=utf-8>
<title>Coding Horror: How Should We Teach Computer Science?</title> 
<link rel="stylesheet" href="http://www.codinghorror.com/blog/styles-site.css" type="text/css" /> 
<link rel="stylesheet" href="http://www.codinghorror.com/blog/styles-site-mobile.css" type="text/css" media="handheld" /> 
<link rel="stylesheet" href="http://www.codinghorror.com/blog/styles-site-print.css" type="text/css" media="print" /> 
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/codinghorror/" /> 
<link rel="canonical" href="http://www.codinghorror.com/blog/2008/01/how-should-we-teach-computer-science.html">
<link rel="apple-touch-icon" href="http://www.codinghorror.com/.a/6a0120a85dcdae970b017615c1941f970c-pi">

<script> 
var TPApp = {};
TPApp.app_uri = "http://www.typepad.com/";
</script> 

<link rel="shortcut icon" href="/favicon.ico" /> 

<link rel="stylesheet" type="text/css" href="http://static.nrelate.com/common_js/0.02.0/nrelate-panels-all.min.css" />

</head>

<div id="header"> 

<div style="float:left; "> 
<a href="http://www.codinghorror.com/blog/"><img src="http://www.codinghorror.com/blog/images/coding-horror-official-logo-small.png" alt="I &lt;3 Steve McConnell" height="91" width="100"></a>
</div> 
<div style="float:left; margin-top:10px;"> 
<a href="http://www.codinghorror.com/blog/"><img alt="Coding Horror" src="http://www.codinghorror.com/blog/images/coding-horror-text.png" height="25" width="275"></a><br/> 
<span class="description">programming and human factors<br/>by Jeff Atwood</span> 
</div> 

<div style="float:right; margin-top:20px;" id="searchbox"> 
<form action="http://www.google.com" id="cse-search-box">
  <div>
    <input type="hidden" name="cx" value="partner-pub-6424649804324178:5453723522" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>

<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>

</div> 

</div> <!-- header -->

<div id="container"> 
<div class="blog"> 
<div class="blogbody"> 

<h2 class="title"><a href="http://www.codinghorror.com/blog/2008/01/how-should-we-teach-computer-science.html" class="title-link">How Should We Teach Computer Science?</a></h2> 

<h3 class="date">January 12, 2008</h3> 

<p>
<a href="http://www.cs.toronto.edu/~gvwilson">Greg Wilson</a> recently emailed me the following question:
<p>
<blockquote>
I&#39;m teaching a software engineering class to third-year students at the University of Toronto starting in January, and would like to include at least one hour on deployment --- <b>[deployment] never came up in any of my classes, and it&#39;s glossed over pretty quickly in most software engineering textbooks</b>, but I have learned the hard way that it&#39;s often as big a challenge as getting the application written in the first place.
</blockquote>
<p>
Deployment is a huge hurdle. It&#39;s a challenge even for the best software development teams, and it&#39;s incredibly important: if users can&#39;t get past the install step, none of the code you&#39;ve written matters! And yet, as Greg notes, existing software engineering textbooks give this crucial topic only cursory treatment. Along the same lines, a few weeks ago, a younger coworker noted to me in passing that <b>he never learned anything about source control</b> in any of his computer science classes. How could that be? Source control is the very <a href="http://www.codinghorror.com/blog/archives/000643.html">bedrock of software engineering</a>. 
<p>
If we aren&#39;t teaching fundamental software engineering skills like deployment and source control in college today, we&#39;re <b>teaching computer science the wrong way</b>. What good is learning to write code in the abstract if you can&#39;t work on that code as a team in a controlled environment, and you can&#39;t deploy the resulting software? As so many computer science graduates belatedly figure out after landing their first real programming job, it isn&#39;t any good at all.
<p>
Today&#39;s computer science students should <b>develop software under conditions as close as possible to the real world</b>, or the best available approximation thereof. Every line of code should be written under source control at all times. This is not negotiable. When it&#39;s time to deploy the code, try deploying to a commercial shared web host, and discovering everything that entails. If it&#39;s an executable, create a standalone installer package that users have to download, install, and then have some mechanism to file bug reports when they inevitably can&#39;t get it to work. Students should personally follow up on each bug filed for the software they&#39;ve written.
<p>
Will this be painful? Boy, oh boy, will it ever. It&#39;ll be <i>excruciating</i>. Students will hate it. They&#39;ll begin to question why anyone in their right mind would want to write software.
<p>
Welcome to the real world.
<p>
After I wrote my response to Greg, Joel Spolsky posted an <a href="http://www.joelonsoftware.com/items/2008/01/08.html">entry on computer science education</a> that, at least to my eye, seemed hauntingly similar to the advice I offered: 
<p>
<blockquote>
I think the solution would be to create a programming-intensive BFA in Software Development -- a Julliard for programmers. Such a program would consist of a practical studio requirement developing significant works of software on teams with very experienced teachers, with a sprinkling of liberal arts classes for balance.
<p>
When I said BFA, Bachelor of Fine Arts, I meant it: software development is an art, and the existing Computer Science education, where you&#39;re expected to learn a few things about NP completeness and Quicksort is singularly inadequate to training students how to develop software.
<p>
Imagine instead an undergraduate curriculum that consists of 1/3 liberal arts, and 2/3 software development work. The teachers are experienced software developers from industry. The studio operates like a software company. You might be able to <b>major in Game Development and work on a significant game title, for example, and that&#39;s how you spend most of your time, just like a film student spends a lot of time actually making films and the dance students spend most of their time dancing.</b>
</p></p></blockquote>
<p>
This is not to say that computer science programs should neglect theory. Fundamental concepts such as algorithms and data structures are still important. My algorithms class was my favorite and by <i>far</i> the most useful class I ever took for my own computer science degree. But teaching these things at the <i>expense</i> of neglecting more prosaic real world software engineering skills-- skills that you&#39;ll desperately need as a practicing software developer-- is a colossal mistake. It&#39;s what Steve Yegge was alluding to in his <a href="http://steve-yegge.blogspot.com/2006/07/wizard-school.html">fantastical Wizard School essay</a>.. I think.
<p>
There is the concern that all those highfalutin&#39; computer science degrees could degenerate into little more than vocational school programs, something Joel mentioned in his <a href="http://www.joelonsoftware.com/items/2007/12/03.html">excellent Yale address</a>:
<p>
<blockquote>
At Ivy League institutions, everything is Unix, functional programming, and theoretical stuff about state machines. As you move down the chain to less and less selective schools Java starts to appear. Move even lower and you literally start to see classes in topics like Microsoft Visual Studio 2005 101, three credits. By the time you get to the 2 year institutions, you see the same kind of SQL-Server-in-21-days &quot;certification&quot; courses you see advertised on the weekends on cable TV. Isn&#39;t it time to start your career in (different voice) Java Enterprise Beans! 
</blockquote>
<p>
You can have it both ways. That&#39;s why I&#39;m so gung-ho for internships. College CS classes tend to be so dry and academic that you <i>must</i> spend your summers working in industry, otherwise you won&#39;t have the crucial software engineering skills you&#39;ll need to survive once you graduate. Unimportant little things like, say, source control and deployment and learning to deal with users.  I constantly harp on internships whenever I meet college students pursuing a computer science degree. It&#39;s for your own good.
<p>
It does strike me as a bit unfair to force students to rely on internships to complete their education in computer science. Or, perhaps, something even worse. &quot;Want to learn computer science? No college necessary! Just download some ISO images and found your own social networking startup!&quot; Unleashing the naked greed of the TechCrunch crowd on tender young programming minds seems downright cruel.
<p>
So <b>how should we teach computer science?</b> The more cynical among us might say <a href="http://www.codinghorror.com/blog/archives/000635.html">you can&#39;t</a>. I think that&#39;s a cop-out. If students want to prepare themselves for a career in software development, they need to shed the theory and spend a significant portion of their time creating software with all the warty, prickly, unglamorous bits included. Half of software engineering is pain mitigation. If you aren&#39;t cursing your web hosting provider every week, fighting with your source control system every day, deciphering angry bug reports from your users every hour-- you aren&#39;t being taught computer science.
<p>
<p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p>


 
<div class="posted">Posted by Jeff Atwood</div> 

<div id="nrelate_related_placeholder"></div> <script async type="text/javascript"
src="http://static.nrelate.com/rcw_js/0.50.0/loader.min.js"></script>

<div class="footernav">
  
  <div style="float:left;"><a rel="prev" href="http://www.codinghorror.com/blog/2008/01/the-enduring-art-of-computer-programming.html">&laquo;&nbsp;The Enduring Art of Computer Programming</a></div> 
  
  
  <div style="float:right;"><a rel="next" href="http://www.codinghorror.com/blog/2008/01/whats-on-your-keychain-2008-edition.html">What's On Your Keychain, 2008 Edition&nbsp;&raquo;</a></div> 
  
</div>

</div> <!-- blogbody -->




<div class="comments-head" id="comments">144 Comments</div> 


  <div class="comments-body nicholaus_shupe"> 
  <p>Algorithms and data structures, the very core of CS, power all of today&#39;s top notch software products and services.  Without them, we would have no search engines that crawl billions of documents, databases, sophisticated network routing protocols, iPods, video games, distributed computing, etc.  Basically all that&#39;s left is the logic that powers today&#39;s crappy applications that your boss wants to outsource.</p>

<p>Without a basic 4 year education in CS, you&#39;re left with an college graduate who really has no hope of every producing anything of merit unless they&#39;re the rare of exception that&#39;s self driven, and has at least studied the fundamentals on his or her own.</p>

<p>What&#39;s left is software engineering as you mention, which is quite important, but not to the detriment of a proper CS education.  Just as a variety of other posters have mentioned, the university isn&#39;t really a good place to learn this.  A university will never replicate politics, the stress, the budgets, the variety of coworkers (all with different life goals), the customers, etc.  All of which, in my humble opinion, form the majority of problems and issues you&#39;ll face as a software engineer (see your blog a few entries back).  Any attempt at a simulation will be just that.  I can land a 747 in Microsoft&#39;s Flight Simulator, but do you trust me to do the same with your life at stake?</p>

<p>As for technical topics like source control, buy your employees a good book (in this case: <a href="http://www.scmpatterns.com/book/)," rel="nofollow">http://www.scmpatterns.com/book/),</a> have them read it, discuss the concepts as a team, and try to relate the material to your current projects.  The command line switches/etc. can be learned with a man page.</p>

<p>I really hope you post a follow up blog entry.</p>
  <span class="comments-post" style="margin-left:20px">Nicholaus Shupe on January 13, 2008  1:32 AM</span> 
  </div>

  <div class="comments-body mardicas"> 
  <p>Well, i agree that there should be courses that teach source control, but it is not that hard to understand and learn it by yourself.</p>

<p>I think that more critical is to teach the programmer what the user thinks and wants.</p>
  <span class="comments-post" style="margin-left:20px">mardicas on January 13, 2008  1:34 AM</span> 
  </div>

  <div class="comments-body sauron"> 
  <p>You&#39;re making the common mistake here.  Computer science is not software engineering.  Believe it or not, some people do want to just learn the abstract, and there is reason to learn that and that&#39;s what computer science is.  If you want to learn development, take up software engineering.</p>
  <span class="comments-post" style="margin-left:20px">Sauron on January 13, 2008  3:01 AM</span> 
  </div>

  <div class="comments-body john_smith"> 
  <p>I personally believe that the best programmers understand things from the bottom up, starting with the logic gates, microprocessors, assembly language, and then to native high level compiled languages like C++ or D. If you have written a native windows application in C or C++, programming a .net windows app is a walk in the park, and you know whats going on under the hood if you need a pinvoke to work around the frameworks limitations. After a few years learning how everything works under the hood, then I think the focus should be on learning real world application development from the requirements gathering  usability stages to coding, deployment and documentation. The high level languages are great, but a computer science program needs to start with the basics. It should most definitely end with real world application development, including internships or mentoring programs. I think companies would love to bring in students at a low hourly rate for mentoring because finding loyal, experienced help is really hard these days. </p>
  <span class="comments-post" style="margin-left:20px">john smith on January 13, 2008  3:08 AM</span> 
  </div>

  <div class="comments-body patrick_debois"> 
  <p>If there is one thing I wished they teached me more, it is the human interaction. To get a feeling what I mean , there is an excellent webtunnel <a href="http://www.managinghumans.com/" rel="nofollow">http://www.managinghumans.com/</a> .</p>

<p>I&#39;ve done so many technical correct projects but still they fail, due to a lack of human aspects.</p>

<p>Also interaction is often not learned when teached ex-cathedra.</p>

<p>My 2 eurocents.</p>
  <span class="comments-post" style="margin-left:20px">Patrick Debois on January 13, 2008  3:18 AM</span> 
  </div>

  <div class="comments-body af"> 
  <p>I&#39;m on a computer games course and I&#39;ve found nobody knows anything about versioning or repositories, and there seems to be no intention of teaching it either.</p>

<p>Imagine the look of horror on my groups face when I mentioned the word &#39;subversion&#39;.</p>
  <span class="comments-post" style="margin-left:20px">AF on January 13, 2008  3:22 AM</span> 
  </div>

  <div class="comments-body jack"> 
  <p>The ANU&#39;s Bachelor of Software Engineering and Bachelor of Information Technology programs do this to a limited extent, but not for all assignments. In second year, there&#39;s a project worked on in pairs which is submitted through SVN. Third year (and also fourth year for BSEng, who do the projects a second time but manage a team instead of just working in one) include a year-long team project which is all managed with SVN. The third/fourth year projects are sourced from groups in industry, which means that the final product had better be deployable if it&#39;s to be useful.</p>
  <span class="comments-post" style="margin-left:20px">Jack on January 13, 2008  3:25 AM</span> 
  </div>

  <div class="comments-body oliver"> 
  <p>College CS classes tend to be so dry and academic that you must spend your summers working in industry</p>

<p>Today with the advent of bachelors/masters and fees (in Germany), most people are earning money in their summers. It&#39;s to some degree different in Fachhochschulen (more practice, more specialism, furthermore you have to consider something important: a college (in USA) is not an university. There are some colleges which are quality-wise similar to an university, but some colleges are level-wise equal to a German Gymnasium too! At the moment I&#39;m approaching a 2nd &#39;career&#39; or better a 2nd qualification (CS with B.Sc.), so I&#39;m confronted with these differences between the &#39;traditional&#39; way of studying (Diplom, Magister) and the &#39;new&#39; way (bachelor,master). You don&#39;t have the time anymore for such things (but you have to do it somehow).</p>

<p>This is not to say that computer science programs should neglect theory.</p>

<p>Apart from practical considerations like above, there are certain things which have to change. Computer science needs more bandwidth, more focus on &#39;reality&#39; without losing its foundations.</p>
  <span class="comments-post" style="margin-left:20px">Oliver on January 13, 2008  3:29 AM</span> 
  </div>

  <div class="comments-body bob"> 
  <p>Getting a literature degree doesn&#39;t prepare you for a job in publishing.  A chemistry degree doesn&#39;t prepare you for a job at Glaxo.  So why should a CS degree prepare you for a job in the software industry?</p>

<p>You&#39;re confusing academia, which deals solely with the thirst for knowledge, with the vocational.</p>

<p>I think the major problem is that there are very rarely vocational training courses available for programmers starting a new job.  You can bet that the chemists at Glaxo, particularly those taken on as graduates, are sent on extensive training courses on how to apply their knowledge and work with the company&#39;s equipment.  The programmers are probably shoved in the basement and told to get on with it.  They&#39;re expected to pick up SVN as they go.</p>
  <span class="comments-post" style="margin-left:20px">bob on January 13, 2008  3:32 AM</span> 
  </div>

  <div class="comments-body thomas"> 
  <p>I agree with Sauron?! here. Software Engineering and Computer Science are two very different subjects. I&#39;m in the fortunate position learning both and I&#39;ve been in the industry for two years so these concepts aren&#39;t new to me.</p>

<p>But even so, the Software Engineering courses has us doing group projects and we opted to use source safe ourselves, we weren&#39;t taught it. Deployment was also not taught, or had a very brief glance.</p>

<p>University courses seem to lead towards academic pursuits, not the industry. If I wanted to learn programming I would take a tech course.</p>
  <span class="comments-post" style="margin-left:20px">Thomas on January 13, 2008  3:35 AM</span> 
  </div>

  <div class="comments-body domenic"> 
  <p>Yeah, don&#39;t call it computer science if what you&#39;re really teaching is computer engineering. Us computer scientists get all uppity about that...</p>

<p>Seriously, I&#39;ve taken probably 3/4 of the _theoretical_ computer science class that Caltech has to offer. One of the missing classes in that 1/4 was algorithms, which I dropped a few weeks in, because it was just too alien to my thinking to actually be writing pseudocode as opposed to proving things about complexity classes and computability. Hmm, maybe I&#39;m more of a &quot;computer mathematician,&quot; but still, my point stands.</p>

<p>(Wait, did I have a point? Now I&#39;m not sure.)</p>
  <span class="comments-post" style="margin-left:20px">Domenic on January 13, 2008  3:37 AM</span> 
  </div>

  <div class="comments-body wesleyc"> 
  <p>I&#39;m a computer science student, attending a local liberal arts college that just happens to have a decent CS department. While the department is pretty standard, they do have an absolute requirement that you intern at a company for at least a year before graduation.</p>

<p>In my case this presents some problems, since I already have a rather lucrative job in contract web development. I can program circles around  most of the people in the course, but I&#39;m still going to be forced to take time out of my well-paid and enjoyable contract work to work at an  &quot;official company&quot;.</p>

<p>However annoying this may be, the college does do one thing right: they have one course per semester devoted to &quot;special topics&quot;--and that can be any serious topic the students vote for. This semester the course topic is C#/ASP.NET. Last semester, it was PHP. Every semester the course will be updated and a new topic picked, keeping it relevant and fresh.</p>
  <span class="comments-post" style="margin-left:20px">WesleyC on January 13, 2008  3:37 AM</span> 
  </div>

  <div class="comments-body whisper"> 
  <p>What properties should a single line of code have and what they require? At a minimum it would be:</p>

<p>* secure - the programmer should know about security, best practices, their environment, and other factors;<br />
* efficient - the programmer shouldn&#39;t write an O(n^6) algorithm if they can help it;<br />
* readable - the programmer writing the code won&#39;t be the only one to ever read it;<br />
* tested - the line has to be right, right?;<br />
* documented - some record should exist of who wrote the line and why;<br />
* commented - not the same as &#39;documented&#39;, since the &#39;why&#39; here is different; and,<br />
* styled - the programmer should follow best practices, use appropriate libraries, follow convention;</p>

<p>From this perspective it takes both disciplines and lots of education to write a single line of correct, functioning code. But that&#39;s only part of the problem, since after writing that line you have to worry about people, process, requirements, design, and constraints, as well as tools, languages, and environments.</p>

<p>I guess my core point is this: there&#39;s a lot (~10 years worth of education) you have to know to write a single line of code, and there&#39;s even more (taking the rest of your life) to know about dealing with the people that pay you for that line.</p>

<p>In the end arguing over Computer Science and Software Engineering seems silly to me, especially once you add in the people and managements skills you need. It&#39;s like taking a cup and chopping it in half, and then arguing over which half is more important. You need both to get a drink!</p>
  <span class="comments-post" style="margin-left:20px">Whisper on January 13, 2008  3:37 AM</span> 
  </div>

  <div class="comments-body joannes_vermorel"> 
  <p>Being in charge of a software engineering course, I have been wondering about the same question. In my experience, the key element is the &quot;boredom factor&quot; of the course.</p>

<p>I have been discussing about it a while ago.<br />
<a href="http://blog.vermorel.com/?p=28" rel="nofollow">http://blog.vermorel.com/?p=28</a></p>

<p>For example, it takes roughly 30 min to get started with Revision Control, but it&#39;s way much more efforts to learn all the good practices that come along with Revision Control. The job of teacher is to open the path; students, if interested, will make their own make way.</p>

<p>My 2cts on the question,<br />
Joanns</p>
  <span class="comments-post" style="margin-left:20px">Joannes Vermorel on January 13, 2008  3:39 AM</span> 
  </div>

  <div class="comments-body weeble"> 
  <p>Universities are good at teaching abstract concepts and at evaluating whether those concepts have been learned. They are not so great at teaching the practical aspects of software engineering. However, everybody seems to observe this and think &quot;Oh my god, universities are useless! We must make them better at teaching people exactly what it is like to work in industry.&quot; I contend, however, that this is a waste of time.</p>

<p>Practice can be learned on the job, very effectively. Theory, however, is much harder to learn without lectures, workshops and assessments, which universities are well suited to provide. If someone doesn&#39;t get a strong understanding of the theory at university, they may never get it at all. If they don&#39;t learn the practice, but at least have the theory, they will certainly learn on the job. I believe that university courses should focus on what they can do well, the theory part, and not the day to day experience of being a software engineer, for which they are particularly *un*-suited.</p>

<p>Source control is an example of something that, while indisputably critical to the practice of software engineering, is *hard* to teach at university, but *easy* to learn on the job. Hard to teach because you really need to see it working on a sizable project with many members and multiple branches and merges going on. Easy to learn on the job because there are no particularly difficult concepts involved, and no particular creativity is required in the process.</p>
  <span class="comments-post" style="margin-left:20px">Weeble on January 13, 2008  3:49 AM</span> 
  </div>

  <div class="comments-body j_stoever"> 
  <p>What I find much more important to teach is how to learn and figure out new things. Tell the students, &quot;To solve todays homework, you&#39;ll have to find out how to do xxx. It&#39;s not in the books or the scripts for this lesson. Good luck.&quot;. Because that&#39;s how it works in real life. Better learn how to Google and how to use your results.</p>
  <span class="comments-post" style="margin-left:20px">J. Stoever on January 13, 2008  3:53 AM</span> 
  </div>

  <div class="comments-body jeff_atwood"> 
  <p> Easy to learn [source control] on the job because there are no particularly difficult concepts involved, and no particular creativity is required in the process.</p>

<p>This has not been my experience when working with clients. Most programmers never fully grasp source control beyond the most absolute basic of &quot;I&#39;ve got a lock&quot; concepts. I also think source control is a much deeper and far more complex subject than you allow.</p>

<p><a href="http://www.codinghorror.com/blog/archives/000968.html" rel="nofollow">http://www.codinghorror.com/blog/archives/000968.html</a></p>

<p>I also dispute the idea that you can&#39;t &quot;work on a sizable project with many members and multiple branches and merges&quot; in a university setting. Perhaps they could try having students contribute to an existing open source project of some kind, even in a small way?</p>
  <span class="comments-post" style="margin-left:20px">Jeff Atwood on January 13, 2008  3:56 AM</span> 
  </div>

  <div class="comments-body josh"> 
  <p>I recently developed a very small app for a friend of mine in visual C++. The app took me about 3 hours to create, debug, and test. It took me about 2 weeks to deploy. </p>

<p>I realised then, that I&#39;ve spent 3.5 years at university (2 separate courses) and never learnt how to deploy an application properly. What&#39;s worse - there seems to be no great literature or step by step instructions on deployment! Why .net doesn&#39;t have a simple &#39;deploy&#39; button is beyond me.</p>

<p>University is so behind the times. Recently doing an Internet Client Side computing, we were taught that there&#39;s over 1,000,000 web pages. NO WAY!! THAT MANY?!</p>

<p>However I&#39;m looking forward to this year - teams of 4-6 are to develop an application over the whole year for actual clients. Industry grade. All documentation, user-guides, manuals, charts etc. Let&#39;s just hope they require source control and really teach us deployment while they&#39;re at it! Oh oh, and finally.. a Design Patterns subject! About time.</p>
  <span class="comments-post" style="margin-left:20px">`Josh on January 13, 2008  4:06 AM</span> 
  </div>

  <div class="comments-body moschops"> 
  <p>I agree with many of the comments here, in that the science of computing has nothing to do with competently writing software. </p>

<p>What the bejesus does &quot;web hosting ... source control system ... angry bug reports from your users every hour&quot; have to do with science? That all sounds like some kind of practical software writing to me. Having a firm grasp of the science of computation would certainly help to develop your algorithms, but source control, bug tracking, and all that gubbins are not part of the science. If that&#39;s the way the student wants to go, they should take software engineering instead.</p>

<p>To paraphrase Dijkstra, calling it computer science is like calling surgery knife science, and gives completely the wrong idea. Perhaps it should have been called &quot;Computational Mathematics&quot;; take the emphasis away from this tool called a computer.</p>
  <span class="comments-post" style="margin-left:20px">Moschops on January 13, 2008  4:18 AM</span> 
  </div>

  <div class="comments-body andy_brice"> 
  <p>Computer science and software engineering are (or should be) as different as physics and civil engineering. Software engineers need to learn some computer science in the same way civil engineers need to learn some physics, but they aren&#39;t the same thing at all. We need some computer scientists in academia to research new languages and technologies, but people wanting to be commercial software developers should study software engineering. I believe it has been a huge mistake to think that a degree in computer science is a good grounding for commercial software development.</p>
  <span class="comments-post" style="margin-left:20px">Andy Brice on January 13, 2008  4:24 AM</span> 
  </div>

  <div class="comments-body john"> 
  <p>My university BSc(Hons) Computing class is exactly what you describe.</p>

<p>You learn about how (and why) source control is vital<br />
You learn how to deploy software for different environment (from user installs, to network based installations)<br />
You learn three application development languages, three scripting languages.</p>

<p>You also have more Sciencey type modules, where you learn about Software Execution Models, Compiler Theory and the obligatory Algorithm design, but all in all, it focuses as much as is sensible, on application development (web and desktop).</p>

<p>I&#39;ve no real opinion on which is the better approach for new students to take, but I think thats because, for a successful project, you need all different skill sets.</p>

<p>If for example, you were developing a client/server application to handle some kind of user input, it might be sensible to have a Software Engineer to develop the client-side UI code, and the core of the server, but you still need someone to come in and say &quot;This can be made 20% faster if we do X&quot;, or to design the communications protocols and be able to actually methodically analyse the workings of the program.<br />
</p>
  <span class="comments-post" style="margin-left:20px">John on January 13, 2008  4:31 AM</span> 
  </div>

  <div class="comments-body jd_martinho"> 
  <p>I&#39;m finishing my 4th year overall (1st of Masters Degree in Portugal now with the Bologna naming) and yes, there were no classes on subjects and tools like cvs and deployment, but i guess that depends on the master you choose, there are people going to AI, myself at networking and systems, information systems and software engineering. I really don&#39;t know the specs for the classes given in software engineering so i can&#39;t really say that those subjects are discussed. Altough i think its important i don&#39;t think it&#39;s that necessary, mostly because, like many have mentioned before, the university environment is academic. For instance, now i will have to go on a internship for my last year where i will get the real world treatment and assignments that (supposedly) will complement what i learned in the university.<br />
Also on my 3rd year at a previous university i was involved on a 9 people project with full CVS control and deployment of a Java based web services system. Let me tell with was not pretty, not only because we were rushed into the subject with no previous preparation but also because the teachers didn&#39;t pay much attention to the subject in classes. Also we were not in any way prepared to manage a 9 men team :)</p>
  <span class="comments-post" style="margin-left:20px">J.D. Martinho on January 13, 2008  4:34 AM</span> 
  </div>

  <div class="comments-body jeff_atwood"> 
  <p> Well, i agree that there should be courses that teach source control, but it is not that hard to understand and learn it by yourself.</p>

<p>Not really my point; source control should be seamlessly integrated into all the code you write in CS classes. It&#39;s not necessarily a class you take, it should be more like the air your breathe.</p>
  <span class="comments-post" style="margin-left:20px">Jeff Atwood on January 13, 2008  4:38 AM</span> 
  </div>

  <div class="comments-body weeble"> 
  <p>  [Source control is easy to learn and not a creative process]<br />
 This has not been my experience when working with clients. Most programmers never fully grasp source control beyond the most absolute basic of &quot;I&#39;ve got a lock&quot; concepts. I also think source control is a much deeper and far more complex subject than you allow.</p>

<p>I may not have sufficient experience on the subject. I had limited exposure to source control at university, but where I work now we use Perforce (mostly using cvs for our own projects with little instruction), and it didn&#39;t seem particularly hard to get up to speed on the basics of it, including making branches and integrating between them. I would have thought that a company with a good source control system will not have difficulty teaching graduates to use it, and a company with a bad or non-existant source control system isn&#39;t likely to be the sort of company that will care whether graduates know about source control. Of course, if graduates are forming their own start-ups, then they will definitely benefit from learning a bit about source control at uni. But surely such individuals would have already found out about such things on their own initiative?</p>

<p> I also dispute the idea that you can&#39;t &quot;work on a sizable project with many members and multiple branches and merges&quot; in a university setting. Perhaps they could try having students contribute to an existing open source project of some kind, even in a small way?</p>

<p>I don&#39;t claim that it&#39;s impossible, but I believe that it is not easy to oversee, and that it&#39;s not representative of source control in a corporate setting. For one thing, many open source projects don&#39;t even give source control access to anyone who comes along, and they must instead construct patches and sent them to committers. And even if they do, how does the university evaluate their students&#39; contributions to the project? Students already complain of unfairness in team projects when all the team members are students on the same course! Again, it&#39;s not impossible, and I would certainly be interested to hear stories of how it works in practice, but I still feel that overall it&#39;s a lot more effort than it would be for the graduates to learn the same things on the job.</p>
  <span class="comments-post" style="margin-left:20px">Weeble on January 13, 2008  4:49 AM</span> 
  </div>

  <div class="comments-body mark"> 
  <p>I&#39;ve scanned the comments, so if I repeat anything, sorry about that.</p>

<p>I&#39;m going to draw on my experience as a recent graduate from NC State University with a Comp. Sci. degree.  While NC State isn&#39;t a perfect school, it does comes close to what you&#39;re looking for Jeff.</p>

<p>We had a range of classes that covered all sorts of topics, as we were certainly required to learn our share of theory.  But there were two courses required for all CS majors, Software Engineering and Senior Design, which emphasized more software engineering over theory.    </p>

<p>In Software Engineering (the class) the focus of the class was a group project, and each group was required to use SVN and to write JUnit tests (NC State is primarily a Java school, but I also wrote in C, C++, C# and  Assembly while I was there.  And Prolog - how I hate Prolog.).  It was also the class in which we were introduced to design patterns.  Now, I admit that I didn&#39;t internalize much of the stuff at the time, as about the only design pattern I came out of the class recognizing was MVC, but it was an introduction to it all.</p>

<p>Senior design was the capstone for it all.  Small groups of students were formed and we were assigned to complete projects for companies such as Intel, Nortel, Northrup Grumman, Microsoft, Red Hat (It helps when their headquarters are located 100 feet from the new Comp Sci building), etc.  Now, in Senior Design we were given the freedom to complete the project in almost any way we saw fit, but the expectation was that we used what we had learned while satisfying the requirements given to us by the company who had developed the project.</p>

<p>NC State also seriously stressed internships and co-ops.</p>

<p>Looking back in hindsight, I think that because of the emphasis on building software that I did loose out on some theory.  Once I entered the work force I also realized there was a lot I didn&#39;t know - but my school had at least given me an introduction to it all, with the exception of deployment.  I don&#39;t think that was ever really covered.</p>

<p>I even had a professor who encouraged us to read Code Complete.  He gave it away as a prize to students who did the best on the coding assignments in his class.  Of course, I didn&#39;t manage to follow his advice and pick up the book until after I was out of school.</p>

<p>Now, is NC State&#39;s model the one model that should be followed? I don&#39;t necessarily think so.  I think having a diverse array of models that produces Comp. Sci. graduates with a range of skills is the best.  But as a student, it is nice to have an option of what kind of academic model you would like to follow and to know which schools follow which model.</p>

<p>So there&#39;s my experience, for what it might be worth.</p>
  <span class="comments-post" style="margin-left:20px">Mark on January 13, 2008  4:52 AM</span> 
  </div>

  <div class="comments-body ben"> 
  <p>How long does it take to learn to use source control? Thirty minutes? Sixty?  So what if they don&#39;t cover it in school.  I suspect most schools devote part of a lecture to it somewhere along the line.  I got fifteen minutes on the basics of vi back in the early nineties.  I can&#39;t really say I needed an entire course on editing.  I work with a number of software engineering majors, and for the most part I find the computer science majors to be more useful.  For whatever reason the CS majors have more programming experience.  Regardless of major, the people who don&#39;t read books and try new technologies are useless before long.  So hand new hires a book on source control and see if they read it.  If not, let &#39;em go.</p>
  <span class="comments-post" style="margin-left:20px">Ben on January 13, 2008  4:54 AM</span> 
  </div>

  <div class="comments-body paolo_b"> 
  <p>I&#39;m a current third-year CS student at Fla State. I&#39;ve been programming since I got my first computer and I&#39;ve always been a diligent student of the subject instead of just throwing things together, so you could say I know more than some of my peers. Either way, though, the amount of information they give us in classes is ludicrous to say the least. I&#39;m obviously not done yet, but if the trend in my classes continues I&#39;m going to graduate knowing absolutely nothing more than what I started off with.</p>
  <span class="comments-post" style="margin-left:20px">Paolo B. on January 13, 2008  4:59 AM</span> 
  </div>

  <div class="comments-body frans_bouma"> 
  <p>Universities aren&#39;t about teaching how to apply tools, they&#39;re about theory. If tools are required to teach theory, all the better, but the tool isn&#39;t taught, the theory is. If you want to learn how to use a tool, e.g. a programming language, .net, vs.net, svn, just buy a book or read the manual. If you want to learn the theory behind concurrent usage of textfiles in a versioning system, attent the course at the university where they MIGHT use svn to teach the theory, but perhaps also their own in-house system. </p>

<p>Above, there&#39;s a comment from someone who claims universities are so behind. I can&#39;t disagree more. Perhaps that person has looked at a bad university, but if I check what for example Dutch universities are doing in the field of CS, it&#39;s awesome stuff, and when I then look at the &#39;real world&#39;, the real world is lagging, which is good.</p>

<p>I always find it funny when some student whines about the languages taught at some university: &quot;Why do we have to learn prolog, or miranda? No-one uses these languages in projects!&quot;.... it&#39;s not the language that&#39;s being taught, it&#39;s the theory. The language is just used to get the material across. </p>
  <span class="comments-post" style="margin-left:20px">Frans Bouma on January 13, 2008  5:00 AM</span> 
  </div>

  <div class="comments-body patrick"> 
  <p>What&#39;s wrong with how the ACM thinks CS should be taught? They lay out a very nice curriculum with the understanding that it is a &quot;science&quot; and should be taught as such. I chose my university, not only because of the price - but because it follows the ACM&#39;s guidelines to a &quot;T&quot;. I like the idea of a governing body, such as the ACM, providing a model for universities to follow... much like accreditation, if the school you were going to wasn&#39;t accredited.. would you stay? </p>

<p>Experience will be a contributing factor for when CS graduates look for work - this isn&#39;t much different from other fields, if you want the job you&#39;ve been dreaming of. Pretty much old news. </p>

<p>Let&#39;s remember the reason for higher education, to instill in its students the tools they need for /learning/ for the rest of their lives, not to teach two year old tools that are not going to exist three years from now or become deprecated. Higher education is more of a process of learning how to learn - in that same token, learning SVN on the job shouldn&#39;t be that difficult, considering it takes no more than a few hours to learn.</p>
  <span class="comments-post" style="margin-left:20px">Patrick on January 13, 2008  5:07 AM</span> 
  </div>

  <div class="comments-body james"> 
  <p>I agree with the first comment - there is a distinct difference between computer science and software engineering though there is a good degree of overlap. The former is concerned with the advancement of theory, the latter with its application.</p>

<p>Regarding source control - Jeff is right. Many developers never get beyond the &quot;I have a lock&quot; phase. Some never have to. Most do, or rather, should but its amazing how new the concepts of merging and branching are to many developers and how many codeshops lives could be made easier if they got to grips with source control (and configuration management as a whole).</p>
  <span class="comments-post" style="margin-left:20px">James on January 13, 2008  5:09 AM</span> 
  </div>

  <div class="comments-body rob_o"> 
  <p>Well, it&#39;s just silly to think that a computer science program should be all theory and no real-world, practical training.  Perhaps some students take physch courses for the theory - the abstract concepts - but I doubt very seriously that anyone really takes a course in the computer science roster out of pure academic curiosity.  There has to be a certain degree of vocational-type training involved.</p>

<p>Back on the deployment tangent, students must also be made aware that software deployment doesn&#39;t occur via physical media or on a single PC at a time anymore.  If your app can&#39;t be pushed out via Group Policy, SMS, or distributed via some other desktop management tool across my LAN/WAN to 1000 users in one fell swoop, I&#39;ll be looking for an alternative app.</p>
  <span class="comments-post" style="margin-left:20px">Rob O. on January 13, 2008  5:20 AM</span> 
  </div>

  <div class="comments-body j_stoever"> 
  <p>Studying CS is like studying architecture. Even if you finish, it doesn&#39;t mean you can build a house on your own. For one thing, nobody taught you how to use a hammer.</p>
  <span class="comments-post" style="margin-left:20px">J. Stoever on January 13, 2008  5:44 AM</span> 
  </div>

  <div class="comments-body marcus"> 
  <p>I&#39;m gonna go with first commenter. Comp sci isn&#39;t software engineerig, any more than mechanics is bridge building.</p>

<p>Anyway, I studied a five year master in comp. sci and comp. eng. (what we in sweden call Civilingenjr, Datateknik) which is basically a mix between ee and cs.</p>

<p>They way they&#39;ve chosen to teach &quot;real life&quot; is pretty decent, I think. We have one course covering the theory of software engineering (processes and project models, scm, etc) and a few project courses testing this, where we&#39;re put in groups of six-ten people, given a project at a company and a methodology to follow (agile) and a problem we have to develop software to solve. Source control, structured testing, etc., is mandatory. The projects usually last five weeks, although those five weeks are spread over a semester.</p>

<p>It&#39;s a good model I think more schools should try. Two-three projects really grows your strengths in software engineering.</p>
  <span class="comments-post" style="margin-left:20px">Marcus on January 13, 2008  5:44 AM</span> 
  </div>

  <div class="comments-body josh"> 
  <p>Jeff,</p>

<p>I actually consider that I had a pretty fantastic education. I attended East Tennessee State University, and was actually advised by a gentleman who worked at Oak Ridge National Lab. He told me that if I wanted a very practical education with lots of hands on experience that was the best place in the area.</p>

<p>The first two years are what I would call the theory years with heavy emphasis on data structures, file processing, computer organization and math. In fact I really think the first three semesters were designed to make you quit. If after staying up all night implementing a sorting algorithm in assembly, or a B+ tree in C++, you still have the warm fuzzies about being a programmer then you are probably born to do this stuff.</p>

<p>However we were in for a real shock. After all the afore mentioned stuff is candy to CS geeks like ourselves. Year three rang in the dreaded &quot;Software Engineering I&quot; and &quot;Software Engineering II&quot;. A year long adventure in writing software, start to finish, for a real client (usually) and all the resulting headaches thereafter. The course was a laughable 3 credit hours per semester, but it took up at least 20 hours per week of my time. Team dynamics, configuration management problems, issues with learning new technologies (PHP / MySQL -- we learned with C++ and Oracle), made us all hate the project and each other for a while. I seriously considered my choice of profession during the final month of the project where a handful of people programmed day and night to get the project out by the deadline, all the while trying to keep up with the &quot;theory&quot; that the class material was based on.</p>

<p>We all wanted to slit our wrists, but in the end we learned valuable lessons that would stick with us in our professional careers.</p>
  <span class="comments-post" style="margin-left:20px">Josh on January 13, 2008  5:48 AM</span> 
  </div>

  <div class="comments-body mattman206"> 
  <p>Things that I never learned, or even heard of, in school:<br />
-Soucre Control<br />
-Deployment<br />
-Unit Testing<br />
-Bug Tracking<br />
-Documentation Generation<br />
-Design Patterns</p>

<p>That&#39;s a pretty big gap of need-to-know-stuff that I was missing.</p>

<p>I even realized the need for good collaborative tools when working on a 4-person senior design project and....set up a wiki.  Because that&#39;s all I knew about.  In the end the project was a complete failure, mainly because we didn&#39;t know about any of the things in the above list, and neither did our advisor.</p>
  <span class="comments-post" style="margin-left:20px">mattman206 on January 13, 2008  6:01 AM</span> 
  </div>

  <div class="comments-body stuart_p_bentley"> 
  <p>Digipen works pretty much exactly like that. You get your SVN by your second class.</p>
  <span class="comments-post" style="margin-left:20px">Stuart P. Bentley on January 13, 2008  6:08 AM</span> 
  </div>

  <div class="comments-body edward_patel"> 
  <p>(Also from Sweden) How old is the oldest programmer at your office? I&#39;m 40 now and still coding (have a MSc in CS degree). I can still work as a programmer because I have my own company and work as a consultant. But most common I think is that after the studies one only work 5-8 yrs coding and then becomes some kind of manager. And this because most programmers are just having it as a job. Think you put the finger on that once <a href="http://www.codinghorror.com/blog/archives/001002.html" rel="nofollow">http://www.codinghorror.com/blog/archives/001002.html</a><br />
So what is left for us who love to program? how many do you know that have written a whole program by them self? and can we be sure the teachers really know what they should teach? I&#39;m a bit cynical and seem always to get that quote in my head about teachers being those &quot;who can&#39;t cut it, if they could they be doing it&quot;</p>
  <span class="comments-post" style="margin-left:20px">Edward Patel on January 13, 2008  6:15 AM</span> 
  </div>

  <div class="comments-body carra"> 
  <p>Just having completed a engineering/computer science degree, I suppose I can&#39;t complain.</p>

<p>Most classes are split in theory  labos. Algorithm theory would explain how black trees work, the labo would let us implement it in c++/editor of choice. Gui design would explain us how to create a good Gui (yeah...), the labo let  us implement it in Visual Studio  vb.net/C#.net. OO in java/netbeans, networking in c/textpad, windows in vbscript (the horror), unix in perl etc. </p>

<p>And some combined projects with multiple people which would use CVS and combine classes. Website  db or GUIs  computer graphics theory. And of course ending with a &quot;now install this website on the apache server).</p>

<p>So yes, I did get all the basics like algorithms, OS, networks, databases, compilers, hardware, computer graphics, OO, security,... But also got to see multiple languages (Java, vb.net, c, c++, c#  perl, vbscript, bash script...) and some environments to use them in.</p>
  <span class="comments-post" style="margin-left:20px">Carra on January 13, 2008  6:26 AM</span> 
  </div>

  <div class="comments-body daniel"> 
  <p>An interesting note thats getting repeated here alot. CS is not SE. Nor is it any sort of practical degree. It&#39;s a science. Based on algorithms and proofs. <br />
While I agree that most CS degrees are too theorectical and should include more &#39;lab&#39; time, and should cover stuff like robust development, that is not their focus.</p>

<p>Jeff, what you are asking for is a software engineering degree, a BSc or a BA, either way, it&#39;s not CS. Software engineering should cover debugging, testing, deployment, proper development practices, etc. It should cross over with CS in data structures and such and avoid getting bogged down in the more theorectical aspects. But don&#39;t diluate a CS degree. They&#39;re just not the same.</p>

<p>It&#39;s the same that nowdays, many universities offer mathematics degrees and applied math, which focuses on real world aspects. <br />
Confusing the two(CS and SE) will just bring more problems to the industry. </p>
  <span class="comments-post" style="margin-left:20px">Daniel on January 13, 2008  6:31 AM</span> 
  </div>

  <div class="comments-body jonathan_parker"> 
  <p>I remember looking at course outlines for my CS degree and noting that much of what is under &quot;Achievements&quot; is generic skills such as analysis skills and problem solving skills.</p>

<p>DON&#39;T DISCOUNT THESE!</p>

<p>I was taught in Uni that the human brain can fit at most 7 things in it at once. Practicing trying to fit more than this in your mind at once is a skill that can be used across all of the IT industry. Across many other industries as well I imagine.</p>

<p>Given the time constraints of a 3 year CS degree I think the intense focus on generic skills is justifiable. Claiming that students are ready for the workforce is NOT. They are as ready as they can be in 3 years.</p>
  <span class="comments-post" style="margin-left:20px">Jonathan Parker on January 13, 2008  6:42 AM</span> 
  </div>

  <div class="comments-body david_ginger"> 
  <p>NO ! NO !</p>

<p>Yes get the students to develop as many non-trivial projects as possible, but NEVER EVER DICTATE,</p>

<p>A fundamental part of learning is DOING.</p>

<p>ALL my problems with Computer Science at University came down to I HAD THE EXPIRENCE - THEY MADE ME DO IT WRONG !</p>
  <span class="comments-post" style="margin-left:20px">David Ginger on January 13, 2008  6:44 AM</span> 
  </div>

  <div class="comments-body jonathan_paul_madrid_abaca"> 
  <p>Another thing that they should teach in computer science classes is how to stand up to the client when they ask for a system that is a coding horror.</p>

<p>No pun intended.</p>
  <span class="comments-post" style="margin-left:20px">Jonathan Paul Madrid Abaca on January 13, 2008  7:02 AM</span> 
  </div>

  <div class="comments-body larry_lard"> 
  <p>Echoing the rest - computer science is not software engineering, and the constant conflation of the two makes this post awkward reading.</p>

<p>I&#39;ve been told it was Dijkstra who said (although wikiquote has it as unsourced) that &quot;Computer Science is no more about computers than astronomy is about telescopes.&quot; My personal take is that &#39;computer science&#39; is something we&#39;re stuck with for historical reasons: a terrible name for a subject that is really a branch of mathematics.</p>

<p>By all means let us do as Joel suggests, and have universities teach **software development** (not &#39;engineering&#39;, note - engineers have to get things right first time). But let&#39;s not pretend that source control is anything to do with computer science.<br />
</p>
  <span class="comments-post" style="margin-left:20px">Larry Lard on January 13, 2008  7:09 AM</span> 
  </div>

  <div class="comments-body jamie"> 
  <p>I can really relate to this article. I don&#39;t think I had a single class on deployment or on source control. And I should have. I really needed it. <br />
When I got my first programming job I had to learn how to best deal with version control and with creating decent user friendly install scripts. Not anything I had ever learned in school.</p>
  <span class="comments-post" style="margin-left:20px">Jamie on January 13, 2008  7:12 AM</span> 
  </div>

  <div class="comments-body lorenzo"> 
  <p>CompSci or SoftwareEngineering, plus variations on the theme.</p>

<p>Once upon a time a long, long time ago, I worked for what is now a major player in the desktop computer manufacturing business. At that time computers were sold via independent dealers. The dealers had a problem: how to train a high school graduate to fix a computer such that the fix was effective, but that the tech was unemployable anywhere else, hence keep his wages low.</p>

<p>The BigComputerCompany hired a PhD in education to develop such a cirriculum. And, he did and he and the company were extremely proud of the results. That, it would appear, became the model for tech support for every company that has to service and support a computer.</p>

<p>This same model appears to be getting into educational philosophy driven by industry everywhere. The local community college teaches a &quot;network technician&quot; course, for example. I talked to an instructor on the course. He told me that industry, via the state&#39;s &quot;Employment Development&quot; department, spec&#39;d out the program. It is exactly what was in place at BigComputerCompany: teach &#39;em exactly how to plug in an RJ45; how to put a switch in a rack. Nothing more. Whatever you do, don&#39;t teach &#39;em to think.</p>

<p>It saddens me.<br />
</p>
  <span class="comments-post" style="margin-left:20px">Lorenzo on January 13, 2008  7:13 AM</span> 
  </div>

  <div class="comments-body david"> 
  <p>I am not sure about the premise of the article. Particularly today, I think most of the mentioned things (deployment, bug tracking, source control) can be easily learned outside the pure academia, for example working on open source projects. Source control system is easy, I think: anynody who could follow theoritical courses on computer science should be able to understand the concept behind svn/svn/mercurial in one hour. The practise is then... well, a question of practice.</p>

<p>Actually, using open source as an excuse to teach the concepts of source control and co could be the way to go, IMHO. That&#39;s where I learned all this stuff myself.</p>
  <span class="comments-post" style="margin-left:20px">David on January 13, 2008  7:28 AM</span> 
  </div>

  <div class="comments-body johnny"> 
  <p>I switched to a physics course halfway through my third year into a cs degree. I was doing well in the abstract classes, but the heavy reliance on the visual studio/eclipse ide environments early in the CS program made it harder to handle the programming during the abrupt switch to the unix environment and command line in year 3. One of the big deciding factors in switching majors was the Computer Scientist vs.Computer Programmer discussion I had with my advisor. I like solving problems, but frankly many computer problems aren&#39;t as interesting to me as other areas of mathematics or science. here is a nice bit of overlap though, and I have had many chances to enhance my programming skills working on models. The best programming lessons I received were from trial and error and lots of reading on my own - books like Code Complete, g++ for linux, sed  awk, etc....which has led me to a position writing code for an aerospace consulting firm that I am enjoying very much. Programming is like an art or sport - the more you practice, the better you get. oooops I didn&#39;t mean to pontificate that much, I did have a cool internship during school building an installer in NSIS for an application. It was a great introduction to the real world issues of software development and delivery. </p>
  <span class="comments-post" style="margin-left:20px">johnny on January 13, 2008  7:46 AM</span> 
  </div>

  <div class="comments-body avdi"> 
  <p>I&#39;m biased, because I moved straight into full time software engineering at a big defense contractor at the age of 18, having only a couple years of part-time community college.  I&#39;ve been profoundly underwhelmed since then with the preparation for real-world coding that college gives to new programmers.  Even Phd&#39;s in CS often have no appreciation for the pragmatics involved in delivering software.</p>

<p>My opinion?  You can&#39;t teach software engineering in a classroom, period.  It should be taught the way crafts used to be taught, with apprenticeship.</p>
  <span class="comments-post" style="margin-left:20px">Avdi on January 13, 2008  7:47 AM</span> 
  </div>

  <div class="comments-body wl"> 
  <p>Jeff, I agree with most of your commenters here. College is not vocational school. The purpose of college or university education is to prepare the student to teach himself on the job, to give him enough of a background in a subject to understand why we do things the way we do, so that he can (in time) suggest improvements that will better achieve our goals. A college graduate&#39;s value is in the ability to question the way we operate and devise better processes. That is the reason why 1/2 of a  college course (at the B.A./B.S. level) is general education.</p>

<p>In nearly any job field, the only way to really learn the practical applications is on the job. Have you ever gone into a supermarket and seen a new employee shadowing an experienced one? While you may think he should have learned everything he needed in high school, it takes weeks on the job before that employee is fully productive. This is surely true in other fields as well. Why would anyone make the mistake of thinking that &quot;software engineering&quot; is any different?</p>
  <span class="comments-post" style="margin-left:20px">W^L+ on January 13, 2008  8:03 AM</span> 
  </div>

  <div class="comments-body nobody_real"> 
  <p>Like many of the others, there&#39;s a huge difference between computer science and software engineering.  However, I&#39;ll go one step further and say there&#39;s also a huge difference between software engineering and software development.</p>

<p>Think about the terms &quot;Scientist&quot;, &quot;Engineer&quot;, and &quot;Developer&quot;.  </p>

<p>In the physical world, scientists are people that perform experiments, record such changes, write papers, etc... They are the people at the leading edge of the field.  They are people that push the limits.</p>

<p>Now, think about an &quot;Engineer&quot;.  Think of a Civil Engineer, or Electrical Engineer.  These are people that take well known concepts and *design* real world things.  I say design, because a Civil Engineer doesn&#39;t pick up a shovel or welding torch, an electronic engineer doesn&#39;t actually build the product.  They just create the blueprints.</p>

<p>Now think of &quot;Developer&quot;.  In the real world, so called &quot;Software Engineers&quot; are really &quot;Developers&quot;, but they often have to wear the hats of &quot;Engineer&quot; and &quot;Scientist&quot;.  A Developer would be someone like a &quot;Lab Technician&quot; or &quot;General Contractor&quot;.  But we have much more rigorous seperation of job activities in the physical world than we do in the virtual one.  </p>

<p>A Software Engineer, unlike his physical counterparts, also has to do the heavy lifting.  And it&#39;s often like there&#39;s a whole bunch of architects building a skyscraper, but each only working, and doing all the physical labor, of their little piece.</p>

<p>How stupid is that?</p>
  <span class="comments-post" style="margin-left:20px">Nobody Real on January 13, 2008  8:08 AM</span> 
  </div>

  <div class="comments-body tj_sullivan"> 
  <p>It seems that I won&#39;t be the first to mention that university is *not* about preparation for the real world. That is outside the scope of what university does.</p>

<p>The goal of university is to teach people to *think*. It doesn&#39;t matter if you&#39;re doing an English BA or a Physics BSc: undergrad is about learning critical thinking skills, with a focus on something that interests the student.</p>

<p>As such, the practical aspects of being an in-the-trenches programmer is irrelevant to the goals of university. Of course, any good professor will mention that things like source control and unit testing are good, important things, those are not necessary things that you need to learn in order to solve a problem.</p>

<p>Do I unit test? Hells, yes. Do I use source control? Hells, yes. Did I need a university course to tell me to? Hells, no.</p>

<p>Universities should teach C, they should teach algorithms, they should teach the concepts of object oriented techniques and they should teach about problem solving. Anything else is really the realm of community college programs and work-prep schools, which is where real-world programming is taught.</p>

<p>Now, the real question is should employers place such a high level of importance on a CompSci BSc over a computer studies diploma from DeVry? It&#39;s going to depend on the employer. The BSc grad will have been taught critical thinking skills, the community college grad will have been taught practical technique. It really will depend on the employer&#39;s needs.</p>
  <span class="comments-post" style="margin-left:20px">TJ Sullivan on January 13, 2008  8:21 AM</span> 
  </div>

  <div class="comments-body telos"> 
  <p>I have to take some exception to Joel&#39;s statements about the quality of institutions.  I started off at a 2 year school and had proper courses in C++ and other languages.  After transferring to RIT I found I already knew most of what they were trying to teach me...</p>

<p>That said, we were introduced to source control RIT and the co-ops (paid internships) helped round out the res tof the stuff I needed to know.  I actually spent my first co-op creating an installer package for HP print drivers.  (Mac version, not Windows version which I&#39;ve heard was horrible... so no blaming me!) </p>
  <span class="comments-post" style="margin-left:20px">Telos on January 13, 2008  8:33 AM</span> 
  </div>

  <div class="comments-body james_myatt"> 
  <p>Why do you guys *always* use Computer Science and Software Engineering interchangeably? They&#39;re not the same thing. Computer Science is like Mathematics, while Software Engineering is like Mechanical Engineering. They&#39;re different, but you do have to teach engineers some science for them to understand and apply.</p>

<p>There is a separate argument to be had about why the top schools don&#39;t have (good) software engineering courses, or about how those software engineering course are taught, or about why people expect Computer Science courses to produce good software engineers automatically.</p>

<p>Remember that there are lots of excellent software engineers who never studied computer science or software engineering, like Phil Haack who was a Math major (I think). I suspect it&#39;s more of a case of &quot;Two types of programmers&quot; than the exact content of an individual&#39;s education.<br />
</p>
  <span class="comments-post" style="margin-left:20px">James Myatt on January 13, 2008  8:53 AM</span> 
  </div>

  <div class="comments-body carlos_sarmiento"> 
  <p>I feel that there is an extreme importance in CS students learning how to work in the real world. For example, and architect never sees a lesson called &quot;Pencils 101&quot;, yet because pencils (in a generic sense) are its most important tools he/she has to learn how to use it the university teaches him/her that. Not through a course, but he/she does learn it and professors make sure students learn the differences between an 2H pencil and a HB and how that affects the results.</p>

<p>Now, pencils are not required to know and understand architecture; actually pencils for theory of architecture are completely irrelevant. But the world expects an architect to know how to use a pencil to deliver.</p>

<p>The same is true for CS students. The world at large expects us to produce something. It can be algorithms to solve problems, but it can also be programs to solve more complex problems. We are expected to be able to do both.  And when that happens you need to know how to use the tools required for the job. Just as college teaches you how to use Big-O notation (which is a tool) to analyze an algorithm, it should teach you the theory behind things like deployment or source control (and theory must be reinforced by practice), because it is something that will provide you with more ways to see, understand and present solutions to a problem.</p>

<p>That said, the emphasis has to be in the theory behind these concepts (source control, deployment), because its the only thing that will be useful in the long term (as a difference from a specific tool, which has a shorter lifetime). </p>

<p>But not teaching the theory and uses of these tools (and these tools are orders of magnitudes more complex that the pencil for architects) greatly limits a students capabilities to innovate and provide new ideas to those areas, areas that fall within the scope of CS and that are required for any kind of work.</p>
  <span class="comments-post" style="margin-left:20px">Carlos Sarmiento on January 13, 2008  8:56 AM</span> 
  </div>

  <div class="comments-body shmork"> 
  <p>I do some research work for a history professor who studies how academic disciplines have changed on account of booms and busts. One thing that&#39;s interesting is that as an academic discipline becomes really popular and commercial as computer science did during its boom time in the 1990s the focus changes from intellectual issues and onto social and business issues. Textbooks start having things in them about working with others, not solving theoretical problems. I only did some preliminary work on CS for him (most of it was on Physics, where the effect is very clear in the boom of the 1950s-1960s), but it seemed to follow the same sort of trends. Anyway, I think this is an interesting post to follow up on the Knuth post from yesterday  from what I have read of him he&#39;s very much of the pre-boom generation in his writing, which to my knowledge doesn&#39;t contain a thing about working with others or getting jobs. </p>
  <span class="comments-post" style="margin-left:20px">Shmork on January 13, 2008  8:58 AM</span> 
  </div>

  <div class="comments-body niyaz_pk"> 
  <p>&quot;Unleashing the naked greed of the TechCrunch crowd on tender young programming minds seems downright cruel&quot;</p>

<p>Jeff, I know you didn&#39;t mean anything... :)</p>

<p>Even though I agree with your theme, I also agree with the first comment to this post.<br />
Certainly we should come to common terms.</p>

<p>And: The width of the text is tooooooooo long.<br />
Anything more than 550px is bad.<br />
</p>
  <span class="comments-post" style="margin-left:20px">Niyaz PK on January 13, 2008  9:11 AM</span> 
  </div>

  <div class="comments-body max_kanatalexander"> 
  <p>I do know some classes that have actually involved contributing to open source projects, or working in real-world (or close-to-real-world environments), and everything I&#39;ve heard about them has been positive.</p>

<p>I think open source offers a great educational opportunity, once somebody has reached the level where they are up to contributing.</p>

<p>-Max</p>
  <span class="comments-post" style="margin-left:20px">Max Kanat-Alexander on January 13, 2008  9:23 AM</span> 
  </div>

  <div class="comments-body justin_wendlandt"> 
  <p>The question here is not what do students want out of a degree program centered around computers. It is about what benefits the field as a whole. </p>

<p>People tend to mistake abstract math, logic and other bits of computer science as useless in the &quot;real world&quot;. I would argue that a Computer Science program (especially a Bachelor of Science) stay heavily based on theory. </p>

<p>At the University of Minnesota, they have two computer science degrees. The Bachelor of Arts and the Bachelor of Sciences, the differences are very minor (<a href="http://www.cs.umn.edu/xml_handbooks/handbook.php?page=ugradsection=CS%20Requirements)." rel="nofollow">http://www.cs.umn.edu/xml_handbooks/handbook.php?page=ugradsection=CS%20Requirements).</a> That link shows you the difference between the two. </p>

<p>Now the thing about an undergraduate degree, and a common misconception, is that a Bachelor&#39;s degree just teaches out how to &quot;speak&quot; the language of that discipline. Now one could get into a HUGE debate (That I wish to avoid) about the difference between discipline and philosophy, but my argument is that I would rather people learn the proper discipline of Computer Science than any philosophical aspects underneath it.</p>

<p>I personally would rather not de-value the worth of a Bachelor&#39;s degree by making it &quot;business&quot; specific. If you made the degree based on &quot;programming concepts&quot; then you are teaching a philosophy of a discipline that will become worthless when that language or concept dies out. Teach a person about how that language was created and maybe they can connect the differences and develop their own theories about it. </p>

<p>I guess that will always be the difference between Academia and Business. Business wants trained drones and academia wants to solve the worlds problems. The two don&#39;t mix. If you really want drones go after the junior colleges.</p>

<p>Just my 2 cents.</p>
  <span class="comments-post" style="margin-left:20px">Justin Wendlandt on January 13, 2008  9:26 AM</span> 
  </div>

  <div class="comments-body azlam"> 
  <p>Computer Science and Software engineering are really different. However i still cant understand is why employers are giving more emphasis to Computer Science graduates, when they acutually require is people with skills in practical programming?</p>

<p>I feel a change should come from the industry, not academia;<br />
</p>
  <span class="comments-post" style="margin-left:20px">Azlam on January 13, 2008  9:28 AM</span> 
  </div>

  <div class="comments-body pete"> 
  <p>Got to agree with the difference between computer science and software engineering. I don&#39;t know about the situation in america but in the UK it it harder to find a software engineering degree than a computer science degree. Also the differentiation is often not even made even at the top universities or not explained in literature very well which you need to be told about really at that age. </p>

<p>I personally took a computer science degree and luckily mine did have quite a lot of programming and team programming modules. I think an offer of extra modules to teach something like a microsoft or java certification would be a great advantage when looking for a job after you finish.</p>
  <span class="comments-post" style="margin-left:20px">Pete on January 13, 2008 10:01 AM</span> 
  </div>

  <div class="comments-body colin"> 
  <p>I completely agree.  My Software Engineering course was great and I did learn lots of useful stuff that served me well in practice but I think deployment is under developed.</p>

<p>Even in business it&#39;s commonly overlooked as being a serious activity.</p>
  <span class="comments-post" style="margin-left:20px">Colin on January 13, 2008 10:04 AM</span> 
  </div>

  <div class="comments-body morgan"> 
  <p>but I doubt very seriously that anyone really takes a course in the computer science roster out of pure academic curiosity.</p>

<p>Quite simply, you are wrong. </p>
  <span class="comments-post" style="margin-left:20px">Morgan on January 13, 2008 10:06 AM</span> 
  </div>

  <div class="comments-body chris"> 
  <p>I was accepted to several &quot;higher ranked&quot; programs for CS and ended up attending the University of Cincinnati because of their stellar Cooperative Education program.  Five years, the middle three on a six months school, six months work rotation.  I spent six months learning the theory and pursuing my own stuff, and six months working and learning in a real development environment.  During my first co-op, I was mostly expected to learn stuff like source control, deployment, et cetera, and contribute on a theoretical level (brainstorming sessions and such).  By the end I was basically able to contribute on every level on the project.</p>

<p>If you&#39;re looking at attending school for CS, don&#39;t be blinded by rankings and lists.  Programs like this one will be more useful in the long run, in my opinion, because there&#39;s no class you can take that will give you work experience.</p>
  <span class="comments-post" style="margin-left:20px">Chris on January 13, 2008 10:46 AM</span> 
  </div>

  <div class="comments-body kamil_kisiel"> 
  <p>I think you&#39;re confusing computer science with software engineering. Many computer/software engineering programs teach concepts like source control as mine did. They often include a fair bit of internship/co-op experience as a requisite for graduation. I had already worked in industry for 6 semesters at 3 different companies by the time I graduated That is where I learned the majority of these concepts.</p>
  <span class="comments-post" style="margin-left:20px">Kamil Kisiel on January 13, 2008 10:50 AM</span> 
  </div>

  <div class="comments-body scott_mitchell"> 
  <p>You teach computer science like you teach anything else in life: by teaching core concepts and having the student practice, make mistakes, and learn from their mistakes.</p>

<p>Internships are a great way to get real-world practice. When I was an undergrad I did a &quot;co-op&quot; program, which was an eight month job with a computer consulting company. The college gave some credit, I spent 8 months living in another city and working a &quot;real&quot; job, getting a salary, etc.</p>

<p>That was where I learned about ASP, databases, working in groups, working with clients, writing functional specs, and all the other stuff that happens in the real world, but sadly isn&#39;t covered very much in academic settings.</p>

<p>IMO, all schools should offer a co-op program and make in mandatory to achieve an engineering degree.</p>
  <span class="comments-post" style="margin-left:20px">Scott Mitchell on January 13, 2008 10:56 AM</span> 
  </div>

  <div class="comments-body christopher_baus"> 
  <p>Internships.  This is what makes my alma mater, RIT, a great CS school IMHO.</p>
  <span class="comments-post" style="margin-left:20px">christopher baus on January 13, 2008 10:58 AM</span> 
  </div>

  <div class="comments-body steve"> 
  <p>Is there a good definition for CS or SE education?  Most people build stuff with software, which takes at least some analysis.</p>

<p>It&#39;s too big of a world.  Data structures, algorithms, building classes, scalability, memory management, I/O, languages, etc.  Not to mention the types of things computers are used for, which can be so different.</p>

<p>I was a math major and did numerical analysis programming in FORTRAN and other stuff in Pascal.  Went to a large corp. after college and learned databases, which I learned nothing about in college (no PCs then either).</p>

<p>I guess the real thing I noticed I was missing after school were concepts about memory, binary type knowledge, and at least some assembler, which is valuable since it makes you think about the computer in a careful way.<br />
</p>
  <span class="comments-post" style="margin-left:20px">Steve on January 13, 2008 11:05 AM</span> 
  </div>

  <div class="comments-body imtiaz"> 
  <p>As someone who has already earned a bachelors in Computer Science and looking back on my courses taken I can see why small details like source control was never covered. In upper division I was required to take only one Software Engineering class which amounted to 4 months of discussion of core SE topics including team development projects we were assigned. SE is a large field with so many high level concepts including development models (especially RUP), use cases, design patterns and others. There is only so much that you can stuff into a 1 semester SE class and keep in mind that even the offering of one SE class is really quite gracious in itself as a CS degree certainly does not have to cover that ground whatsoever. So little details like source versioning - while important - can be learned easily through a variety of means outside the classroom.</p>

<p>In fact, I knew little of source versioning in a team environment until I graduated and got my first (and current) job as a software engineer. It took me all of about 2-3 days of using source control and applying diffs to have learned all the basics. The heart of the issue as I see it however is whether we want Computer Science to evolve into a more practical SE-like discipline or let the recent growth of SE degrees offered by universities across the world fill this requirement. Personally I opt for the latter scenario. I believe CS should not even approach some kind of hybrid CS-SE degree unless the classic CS curricula is also offered.</p>
  <span class="comments-post" style="margin-left:20px">Imtiaz on January 13, 2008 11:42 AM</span> 
  </div>

  <div class="comments-body will_sargent"> 
  <p>This is something that McConnell covered in Professional Software Development.  He (and Steve Tockey) worked on a Master&#39;s in Software Engineering program at the University of Washington.</p>
  <span class="comments-post" style="margin-left:20px">Will Sargent on January 13, 2008 12:48 PM</span> 
  </div>

  <div class="comments-body noah_yetter"> 
  <p>Drop the ubiquitous math minor requirement, which is only there as problem solving exercise and to weed out people with short attention spans anyway, and teach actual SOFTWARE ENGINEERING in that credit space.  All the fun stuff like using source control, writing to a commercial API, interfacing with a (non-trivial) database, and so on.  All the things that classes on matrix algebra and differential equations, nor the classes on assembly language and fork(), aren&#39;t doing squat to help you with.</p>
  <span class="comments-post" style="margin-left:20px">Noah Yetter on January 14, 2008  1:09 AM</span> 
  </div>

  <div class="comments-body kg"> 
  <p>&quot;All the fun stuff like using source control, writing to a commercial API, interfacing with a (non-trivial) database, and so on.&quot;</p>

<p>That&#39;s what I consider the boring part of software development. I liked the linear (matrix) algebra in particular, because it led directly to an understanding of 3D rendering (perhaps my favorite field of CS).</p>

<p>The thing is, CS is such a huge field. Some people study it because they enjoy learning about algorithms, compilers, AI, graphics, etc... - stuff that ordinarily is useless in 99% of the industry.</p>
  <span class="comments-post" style="margin-left:20px">KG on January 14, 2008  1:32 AM</span> 
  </div>

  <div class="comments-body mark_tomczak"> 
  <p>Jeff, you bring up some interesting points.</p>

<p>I graduated with a BS in CS from Carnegie Mellon, and I was surprised to learn the differences in the attitude of what Computer Science education entails from my peers at Drexel University. At CMU, one can complete one&#39;s four years without ever touching Visual Studio. In fact, if you twist it right, you can even avoid ever touching C++. </p>

<p>I spent a semester interning out in &quot;the real world&quot; for a small software company and came back humbled about how little I knew regarding practical software development. At one point, I asked my undergraduate advisor whether it was wise to send students out into the world without having used C++. His response was pretty simple: ideally, the CMU education teaches students enough to grasp C++ when they see it, but also enough to understand why C++ should go away. The danger of teaching &quot;practical&quot; skills (as opposed to high-level abstractions) is that you risk creating a generation of COBOL programmers who can&#39;t see the forest for the trees---and who are obsolete when the industry moves onto the next big thing.</p>

<p>We actually used source control in a few projects at CMU, but we never touched on installation. But how DOES one touch on installation? It seems that teaching installation is like teaching Javascript; each individual distribution&#39;s solution is broken in its own special way that has less to do with theory and more to do with history. Given that the core concept---unpacking an executable into someone&#39;s operating environment---is actually relatively simple, perhaps it is better to focus on the deeper theory than the practical step-by-step of the solution. What good is the knowledge of how to write an NSIS script if everyone is now writing web-distributable installers? My time would have been better served if I&#39;d used it to learn network theory and the structure of an operating system so that I know the right questions to ask to understand how an installer has to work on a given architecture.</p>

<p>It&#39;s also worth noting that a lot of people in Computer Science may never be planning to write installable software. CS (at CMU at least) teaches students to know Computer Science with an eye towards academia, not necessarily to go out into industry. There is a wide field of work to be done in algorithm design, cryptography, and various other fields that need never even consider an installer. It&#39;s important for students to realize that if they plan to go out into the working world they will need such skills, but it&#39;s less important to roll them into an already-crowded 4-year program.</p>

<p>I think we ignore the ins-and-outs of writing installers for the same reason that we teach introductory programming in Java instead of C++. While memory management is an important subject, it clouds the core issues being taught in introductory courses. Similarly, the topic of making an end-to-end software distribution solution isn&#39;t as important as writing the software in the first place because---especially in the academic world---people CAN use your software without an installer, but they CAN&#39;T install software that was never written. A good CS education doesn&#39;t need to include an in-depth study of a problem-space as specific as &quot;distributing software to a client&#39;s machine&quot;---there are a lot of scenarios that completely obviate the need for such a skill.</p>
  <span class="comments-post" style="margin-left:20px">Mark Tomczak on January 14, 2008  1:43 AM</span> 
  </div>

  <div class="comments-body matt"> 
  <p>I think Jeff has it right when he says it should be the air you breath.</p>

<p>You often need to be *taught* theory, what you need from tools is *experience*. There is little point doing a course on source control (except for people who actually want to *write* it) it should be a quick practical very close to the beginning of the course where you are given your own personal repository (if you want it) plus teaching of the basics. After that RTFM, you need to learn how to do that so get used to it. After that point all your practicals should use it (and enforce it - submitting them should involve simply providing them with the tag and where the build./make/run scripts are)</p>

<p>It would be like them teaching you how to script... you should damn well know how to learn it yourself (but they should make sure you have access to the documentation)</p>

<p>My course was pretty theoretical and academic but it did two things very well. A lecturer creates a mailing list every year in which every one is subscribed, he is on the list too but rarely delurked. The list was immensely useful for collaborating on touch problems, areas which were unclear, bugs in practicals (they did some things badly :( )</p>

<p>Secondly, if you wanted to explore some aspect in more details for your own enjoyment/experience every single tutor/lecturer (bar one who was rubbish) was more than happy to help you with it.</p>

<p>A university course should, above all else, teach you how to learn. If  they&#39;re really good they should teach you how to teach (at some level since it requires far greater understanding of the subject to teach it than to use it)</p>

<p>That said they never mentioned source control once at mine, that would have been useful, but I&#39;ve never had a problem with it.</p>

<p>For the record they used Java, C, Haskell, CSP, Prolog and more. The only two they gave any serious tutoring on was Haskell and Java (as the basis for teaching functional and OOP). Everything else you were expected to learn yourself. I think Sun paid them a lot of money to include use Java :)</p>
  <span class="comments-post" style="margin-left:20px">Matt on January 14, 2008  1:56 AM</span> 
  </div>

  <div class="comments-body engtech"> 
  <p>Diego, thanks for including that link to my site</p>

<p>I&#39;m constantly amazed at what people in high tech don&#39;t know how to do. I always end up becoming the go-to guy for esoteric tech problems</p>
  <span class="comments-post" style="margin-left:20px">engtech on January 14, 2008  2:16 AM</span> 
  </div>

  <div class="comments-body francis_fish"> 
  <p>When you graduate you know nothing and usually can&#39;t write maintainable code - I&#39;ve seen stuff written by new graduates in a commercial setting where they were trying to get something out quickly and it was plain awful, didn&#39;t stop them being bright or good but without a decent mentor you are lost. You&#39;ve spent your time writing narrow code that is looked at once by a lecturer and thrown away - sensible variable names, clear paths through the default case, using exceptions properly - very hard to do properly until you&#39;ve had to unpick someone else&#39;s mess and realise how bad your own code is. </p>

<p>I&#39;ve been doing this stuff 20 years now and there&#39;s still lots of stuff I don&#39;t know, but at least I know I don&#39;t know it. </p>

<p>I also did a sandwich degree in the UK, where our third year was spent in industry and we went back to finish our degree off. Most of us, to be honest, considered the last year to be a waste of time. But we went back to get that magic door-opening piece of paper.</p>

<p>You need to *study* &quot;Code Complete&quot; and &quot;Writing Solid Code&quot;, plus Jon Bentley&#39;s stuff, and you need to be humble enough to realise you know nothing. This is hard when the ink on that degree you worked so hard for is still wet...</p>
  <span class="comments-post" style="margin-left:20px">Francis Fish on January 14, 2008  3:04 AM</span> 
  </div>

  <div class="comments-body icr"> 
  <p>&quot;The high level languages are great, but a computer science program needs to start with the basics.&quot;<br />
From a computer scientist perspective I would say start from the maths and work down.</p>
  <span class="comments-post" style="margin-left:20px">[ICR] on January 14, 2008  4:07 AM</span> 
  </div>

  <div class="comments-body apeinago"> 
  <p>&quot;A university course should, above all else, teach you how to learn. If they&#39;re really good they should teach you how to teach (at some level since it requires far greater understanding of the subject to teach it than to use it)&quot; - matt</p>

<p>bah, I already know how to learn, I need the coures to train me in the stuff I need to know to get a job.  Computer Engineering for practicallity, wikipedia for theory.</p>

<p><br />
</p>
  <span class="comments-post" style="margin-left:20px">ApeInago on January 14, 2008  4:08 AM</span> 
  </div>

  <div class="comments-body matt_lacey"> 
  <p>If you aren&#39;t cursing your web hosting provider every week, fighting with your source control system every day, deciphering angry bug reports from your users every hour-- you aren&#39;t being taught computer science. </p>

<p>Or rather, you aren&#39;t being taught how it often is.<br />
What about teaching about how it should be?</p>

<p>Tools that work?<br />
A support team who can identify bugs?</p>
  <span class="comments-post" style="margin-left:20px">Matt Lacey on January 14, 2008  4:35 AM</span> 
  </div>

  <div class="comments-body thelazyidiot"> 
  <p>Not really my point; source control should be seamlessly integrated into all the code you write in CS classes. It&#39;s not necessarily a class you take, it should be more like the air your breathe.</p>

<p>Source control isn&#39;t that necessary. Seriously, it&#39;s just a backup. Maybe you&#39;re an idiot not to use it, but that doesn&#39;t make it necessary. ref: Seatbelts.</p>

<p>Similarly, deployment is a platform issue. Tired of hard deployments, blame the platform! Why doesn&#39;t the language/platform vendor make it easier on you? It&#39;s not (always) that difficult.</p>

<p>request: I want a blog/wiki of software best practices that cover anything other than Hello-World complexity appications?</p>
  <span class="comments-post" style="margin-left:20px">TheLazyIdiot on January 14, 2008  6:16 AM</span> 
  </div>

  <div class="comments-body john"> 
  <p>I&#39;m with you on the sentiment, but I agree with others: computer science is not the same thing as software development. University isn&#39;t purely job training, either.</p>

<p>I had to laugh at the quote from Joel Spolsky that there should be Fine Arts degrees in software development. People love to say that what they do is &quot;an art,&quot; but there is no way that software development is fine art. Are fields with similar challenges, such as auto repair or aeronautical engineering, fine art? Of course not. Nothing wrong with that.</p>
  <span class="comments-post" style="margin-left:20px">John on January 14, 2008  6:24 AM</span> 
  </div>

  <div class="comments-body lewis_baumstark"> 
  <p>I&#39;ve taught four semesters of Software Engineering (working on the fifth right now) and I&#39;ve stressed deployment (as well as source control) almost from the beginning.</p>

<p>The main reason?  IT MAKES GRADING A HECK OF A LOT EASIER.  If you don&#39;t specifically require a one-click installer as part of their grade, you can end up spending 15 minutes just getting a student project installed and configured -- this is before you even get around to evaluating the quality of the work.</p>

<p>I would say the hackery involved to get some student projects up and running would surprise you, but it wouldn&#39;t.  We were all students once.</p>
  <span class="comments-post" style="margin-left:20px">Lewis Baumstark on January 14, 2008  6:48 AM</span> 
  </div>

  <div class="comments-body rob_o"> 
  <p>Lots of commenters are slamming others for not drawing the distinction between &quot;computer science&quot; and &quot;software engineering.&quot;  However, many, many colleges and universities do not offer separate courses of study - they lump it all into their CS track.  So, in those situations especially, there must be some vocational training included with the abstract theory.</p>
  <span class="comments-post" style="margin-left:20px">Rob O. on January 14, 2008  6:50 AM</span> 
  </div>

  <div class="comments-body robert_s_robbins"> 
  <p>I think computer science and the programming profession need to be decoupled on the conceptual level. Computer Science for Software Engineers should be understood to be an advanced, academic discipline while workaday business programming for programmers should be understood to be a vocation. If you are a genuis you go to an university to study Computer Science. If you just want a good job you go to community college to learn programming. </p>

<p>I&#39;m just starting to learn SubVersion after reading many programmer blogs and realizing it is an important job skill. But don&#39;t just whine that programmers don&#39;t know anything about source control. Write an easy to follow tutorial on how to set up and use SubVersion on Windows for .NET projects. I found enough information to get me started on the DMB Consulting Blog.</p>
  <span class="comments-post" style="margin-left:20px">Robert S. Robbins on January 14, 2008  6:50 AM</span> 
  </div>

  <div class="comments-body nick"> 
  <p>At my college, CS and SE were different... They started similarly enough, with algorithms and programming basics and concepts, but deviated the second year into the things you speak of (game development, source control, UI, life cycle etcetera). CS students had to only take on SE class, software engineering. </p>

<p>When I graduated and started my job I didn&#39;t know much about source control, merging especially, as well as autoconf and makefiles. This job has been an eye opener, since it relates to scientific computing (clusters), and can run on linux, mac and windows. We have to do a lot of testing and SE work, but we also do a ton of CS solving NP problems and math and statistics! It&#39;s great fun to actually do CS (theory stressing) and, on the side, do advanced SE (lots of environments and testing, and distribution). </p>
  <span class="comments-post" style="margin-left:20px">nick on January 14, 2008  7:42 AM</span> 
  </div>

  <div class="comments-body lkm"> 
  <p>Source control? Are you kidding me? What&#39;s next, learning how to use Visual Studio? Students should not &quot;develop software under conditions as close as possible to the real world&quot; when they study computer science. They should do that in their spare time. Studying computer science means learning the hard stuff. Write compilers, write an OS, learn about concepts and ideas. Design patterns, memory management, chip design, object orientation (in an object-oriented language like Eiffel, not a crutch like Java), designing software. That&#39;s what students should learn. Not how to check in code into SVN. That&#39;ll take a day or two on the job, or when they do an internship.</p>
  <span class="comments-post" style="margin-left:20px">LKM on January 14, 2008  7:44 AM</span> 
  </div>

  <div class="comments-body hinek"> 
  <p>I have to disagree with Joel Spolsky. Software development is not an art. It is an engineering science.</p>

<p>The worst programs i&#39;ve seen were from people who considered themselves: artists.</p>
  <span class="comments-post" style="margin-left:20px">Hinek on January 14, 2008  7:45 AM</span> 
  </div>

  <div class="comments-body rick_cabral"> 
  <p>Since I happen to have a BFA, and I started life as a BS major, I understand Jeff&#39;s stance completely, and couldn&#39;t agree more. It&#39;s not about the definition of Computer Science, it&#39;s that the &quot;assumption&quot; in the non-Computer Science field is that CS majors are qualified software developers.</p>

<p>My degree is in Studio Art, from a run-of-the-mill state university. Fine Arts teaches both theory and practice: history and composition are about advancing the Art, medium-specific classes are about execution, and about MAKING A LIVING PRODUCTING ART. The goal is to NOT SUCK. </p>

<p>A fair parallel to Version Control would be Drawing from Life using Perspective. Perspective takes about 30 minutes to teach, but 100s of hours to master. There are all kinds of props, techniques, mnuemonics, and gizmos that will help you master Perspective. You need the &quot;applied&quot; courses like Drawing 300 to explore each of them with someone who&#39;s made a living at it. (My instructor had a PhD in drawing!!!)</p>

<p>CS could easily accomodate this kind of &quot;applied&quot; degree.</p>
  <span class="comments-post" style="margin-left:20px">Rick Cabral on January 14, 2008  7:57 AM</span> 
  </div>

  <div class="comments-body dave_solomon"> 
  <p>College will hopefully get the framework to be a decent programmer laid out.  With some extra work and some years of experience, that framework may help you to become a decent developer.<br />
I wrote about this on my blog the other day ( <a href="http://48klocs.blogspot.com/2008/01/meaningful-certification-is-hard.html" rel="nofollow">http://48klocs.blogspot.com/2008/01/meaningful-certification-is-hard.html</a> ).  I don&#39;t know where the idea that students spring forth from college with their BA in comp sci fully-formed and ready to develop came from - lawyers and doctors both have long periods of time where they&#39;re mentored AFTER additional years of education.  If you believe that developers are cogs that are easily replaced, I can see how the belief that education can somehow be tweaked to deliver shiny new cogs makes sense.  If you believe that development is as much an intellectual pursuit as the product it delivers (like me) then the notion that there&#39;s any signifier that universally guarantees a solid developer is a pretty laughable one.</p>
  <span class="comments-post" style="margin-left:20px">Dave Solomon on January 14, 2008  8:14 AM</span> 
  </div>

  <div class="comments-body mattkins"> 
  <p>Unfortunately, as capitalism slowly rolls over and dies of its cancer in the US, most private colleges couldn&#39;t care less about how well they are teaching future programmers, as long as that tuition keeps rolling in.</p>
  <span class="comments-post" style="margin-left:20px">Mattkins on January 14, 2008  8:24 AM</span> 
  </div>

  <div class="comments-body rjbotting"> 
  <p>Advert:  The evolution of my dept&#39;s offerings has been in the<br />
direction of many degrees: a traditional BS, a set of BAs<br />
with &quot;practical&quot; options -- web, graphics, games, ... Plus<br />
a Computer Engineering program and Bioinformatics.  </p>

<p>And we have been running internships since 1983.<br />
     <a href="http://csci.csusb.edu/" rel="nofollow">http://csci.csusb.edu/</a></p>
  <span class="comments-post" style="margin-left:20px">RJBotting on January 14, 2008  8:34 AM</span> 
  </div>

  <div class="comments-body psy"> 
  <p>It&#39;s been tried.  There are a few problems with this style of approach.  Take a look at Neumont University.  It&#39;s a relatively new school that focuses entirely on project based development.  From the first quarter until graduation, you&#39;re working with teams of 4-8 developers on quarter-long projects, required to use source control, unit testing software, and with a variety of oddities thrown in based on the teachers whims.  For example, during one quarter, halfway through each team was moved to another team&#39;s project and thus had to read through the code, figure out what was working and what wasn&#39;t, and finish it.  Other quarters involved such oddities as randomly switching team members across groups (getting teams to make sure a new developer can get into the project as quickly as possible).</p>

<p>The school has run into significant problems.  The first was accreditation.  Since it takes 5 years of a college operating before it can actually give out degrees, Neumont bought another college (Morrison University), switched their campus to the main campus, and tried to sidestep the issue.  However, being relatively unknown and due to the way the college is designed, degrees from it aren&#39;t entirely useful.</p>

<p>Second, the dropout rate.  The entire college is practically a proof of the post you linked ( a href=&quot;http://www.codinghorror.com/blog/archives/000635.html&quot;http://www.codinghorror.com/blog/archives/000635.html/a ).  The first quarter has a dropout rate over 50%.  You can tell which rooms are dedicated to first quarter students because they&#39;re 2 to 3 times the size of other classrooms.  I&#39;ve made a point of getting to know as many students as possible and I&#39;ve worked with a lot of first quarter students.  Some of these people have been quite intelligent, but for some reason could just never wrap their heads around some of the key concepts of programming.  While I&#39;m sure that they&#39;ll go on to great jobs in other fields, it&#39;s proof that you can&#39;t just use intelligence as a guide for computer programmers, it requires a specific mindset.</p>

<p>On the other hand, when I&#39;ve visited friends at more normal colleges, I&#39;ve snuck in to a few CS classes with them to see what kind of education they were getting.  Friends in the second half of their junior year of a CS degree were learning concepts that I learned my first quarter.  It seems that the state of CS teaching is in horrible disarray, and while revolutionary new ideas are at least better than what we have, they&#39;re nowhere near what we need.</p>
  <span class="comments-post" style="margin-left:20px">Psy on January 14, 2008  9:04 AM</span> 
  </div>

  <div class="comments-body brian"> 
  <p>I wish our profession was like the medical field.  With time in the field as part of graduating requirements.  I knew a hell of a lot about theory when i graduated.  I knew nothing about how to actually program in the real world.  </p>

<p>It&#39;s taken me a year and a half of self teaching and making blunders to get what little i have down about good practices with source control and deployment.  No one I&#39;ve worked with has been able to mentor in these areas. </p>
  <span class="comments-post" style="margin-left:20px">brian on January 14, 2008  9:14 AM</span> 
  </div>

  <div class="comments-body jay_s"> 
  <p>I graduated from Rose-Hulman, which is one of the classes Joel mentioned on his blog. I graduated just after they decided to split the &quot;Computer Science  Software Engineering&quot; curriculum into two different degrees. Computer Science as I know it is closer to Mathematics. In fact, when I started at Rose, they wouldn&#39;t let a CS major have a minor in Math. You only had to take TWO extra math classes to get it. You were forced to double major if you really wanted that math degree.</p>

<p>The CS curriculum I took did have a few Software Engineering courses, but I don&#39;t remember them. We weren&#39;t focused on that aspect. I do wish I had learned a bit more, as I&#39;m in a SE position now, but I think splitting the curriculum in to two degrees was the right decision.</p>

<p>I do agree, however, that even in CS there should be more use of standard SE tools in projects. Some of those techniques, like version control, is useful to everyone whether they&#39;re doing research programing or product programming.</p>
  <span class="comments-post" style="margin-left:20px">Jay S. on January 14, 2008  9:28 AM</span> 
  </div>

  <div class="comments-body mark"> 
  <p>I am a second year student at a community college chasing my AAS in computer science. Yes, SCIENCE. The idea of having to walk into the fine arts building feels me with dread. How can there be a computer degree in fine arts? Logic is the base of computer science, how would one learn logic in fine arts? I think that this has to be one of the most horrendous ideas that I have ever heard of.</p>

<p>We are lucky at Walters State, the head of the dept worked for 20 some odd years in the field before he started teaching. We learn theory by coding, coding and more coding. In my two years here I have learned (or learning now) five computer languages as well as Cisco networking. </p>

<p>True, I spent last summer as an Intern at Oak Ridge National Labs and none of the languages that I had learned was being used, but the experience of constant coding and problem solving served me well. I was able to jump in and do !research! after my freshman year. Find someone who is seeking  a degree in fine arts do that.<br />
</p>
  <span class="comments-post" style="margin-left:20px">Mark on January 14, 2008 10:12 AM</span> 
  </div>

  <div class="comments-body sam_wilson"> 
  <p>I&#39;d like to give some kudos to Drexel University. I did not attend Drexel, but I have interviewed, hired and worked with a number of Drexel grads.</p>

<p>For those who don&#39;t know, Drexel is a University based in Philadelphia that has a very strong internship requirement. Every Drexel student (at least in Comp Sci) has to complete an internship.</p>

<p>As a result, each of these students has had exposure to a real world environment. For some they had an IT focused internship and they learned a lot about Customer Service and what the day to day job is like. For those who had software development internships they had exposure to source control, documentation and sometimes even deployment.</p>

<p>I&#39;ve seen every Drexel grad achieve a lot of success and be very valuable additions to a team in a very short period of time.</p>

<p>Oh... and Drexel has a Ph.D. program and does a lot of research as well. So, it&#39;s not just a &quot;learn to work&quot; program.</p>
  <span class="comments-post" style="margin-left:20px">Sam Wilson on January 14, 2008 10:20 AM</span> 
  </div>

  <div class="comments-body kalid"> 
  <p>Nice discussion. I graduated in CS 5 years ago, and agree that classes are for learning theory, summers for writing code / getting your hands dirty.</p>

<p>A few assignments really stick out, which helped me:</p>

<p>* Our sophomore-level programming classes *required* all code be checked into RCS. The actual version control system doesn&#39;t matter: understanding the concepts (check in, check out, revert, history, etc.) is what&#39;s important. I don&#39;t think using version control is an engineering detail -- it&#39;s as important as a physicist knowing how to use a calculator. It&#39;s a crucial tool for the job.</p>

<p>* A great programming class had us learn a new language each week. One week it&#39;d be Perl and doing file manipulations. Another was Java for some graphics. Another was implementing grep in C [did you realize a regular expression engine is surprisingly small?]. Another assignment was looking at the sed source code and adding features. Each assignment exposed us to a new aspect of programming.</p>

<p>Computers are an interesting mix of engineering and theory, and you need both. I went to one of the Ivy league institutions, and though it does focus on a lot of theory you get your hands dirty too. It depends on the teacher.</p>
  <span class="comments-post" style="margin-left:20px">Kalid on January 14, 2008 11:01 AM</span> 
  </div>

  <div class="comments-body michael"> 
  <p>The last time the accreditation team came to my department, the Computer Science department at BYU, I was invited to give my input on how our school is doing. Of all the students in the room, the overwhelming responses were &quot;We do not have the chance to write&quot; and &quot;We do not know how it is in the &#39;Industry&#39;.&quot; In the Computer Science Department there is a major split between the Theorists and the Industrialists, with the Theorists holding all the power.</p>

<p>Luckily for us, the students, our voices rang out. We are now required to write reports in all Junior/Senior level classes. We have also added a required course to the Junior Level: &quot;Software Design and Test&quot; which requires the use of SVN. This was extracted from a senior level class &quot;Software Development Processes&quot; which has the class run as a company building software from a &#39;typical&#39; customer with vague requirements, etc.</p>

<p>I have really enjoyed these courses taught by excellent professors. But what&#39;s more, I have enjoyed my internships at Amazon.com which also threw the _need_ for me to speak up on these subjects to our college curriculum committee. Thank heavens they listened.</p>
  <span class="comments-post" style="margin-left:20px">Michael on January 14, 2008 11:41 AM</span> 
  </div>

  <div class="comments-body jens_j"> 
  <p>There&#39;s deployment and deployment. It seems most of you are discussing deployment in the context of packaging a standalone application and making it available for customers to install by themselves. This is indeed a time consuming task, but IMO not a difficult one, and I think packaging is a more apropriate term for it.</p>

<p>The kind of deployment I have seen and worked with, and which does take knowledge and precision is deployment of enterprise level distributed applications. Look at the SOA-trend. Sure, it&#39;s all fine and dandy to develop services and have thin clients consuming them under some kind of domain model with a strictly controlled document format (like WebServices should be), but how do you deploy this and how do you make sure that applications keep working while you upgrade? </p>

<p>I used to work at the IT-department of a very well known swedish furniture company which has just such an infrastructure: All business logic is developed as Java Enterprise Applications which are deployed on WebSphere app servers. Thin clients developed mainly in VB.NET run on citrix terminal servers or PC&#39;s around the world. Everything needs to run 24/7 with minimal downtime, and redundance is required in everything. </p>

<p>Did every developer know how to deploy things into this infrastructure? Heck no! Dedicated deployment managers took care of scheduling update work packages for the operations people etc. Other companies I&#39;ve been working for with more customer packaged applications also have this: Dedicated integrators and packagers make sure that things are configured, built and packaged correctly and then made available through the correct chanels. I belive it&#39;s a waste of good programmers to have them spend alot of time on theese issues, when it&#39;s not really what they are good at, and often not what they want to do.</p>

<p>Should theese thing be part of CS? I think not. To me, CS is, and should be, the science of computer logic. It should not be a vocational education for programmers. </p>

<p>Over here, in Sweden, there are really three (well one might say four) masters programmes that commonly leads to a position in IT. There is the Computer Science programme, wich is a theoretical education about algorithms, compilers etc, you know it. There is the Computer Engineering programme, which has a bit in common with CS, but is much more vocational, and includes more of the practicalities of software development. There also is the System Analysis programme, which has very little technical focus, rather focusing on business analysis, mapping requirements, IT project management, documentation and architecture. The forth one is Cognitive Science, generally focusing on UI-design. Most professionals come from the Computer Engineering programme, I myself did that and the System Analysis. I think this is a good spread, making for people with focused education in specific areas of software development, rather than trying to create one general education for all IT-professionals.</p>
  <span class="comments-post" style="margin-left:20px">Jens J on January 14, 2008 12:33 PM</span> 
  </div>

  <div class="comments-body lord_humungus"> 
  <p>The problem I encounter at my school is that when this is brought up to the administration, they assure us that the course is taught this way! </p>

<p>I think there will always be a disconnect between industry and education because schools are run by educators, not software developers. The people who run the schools are simply incapable of understanding. If you try to explain that the curriculum is insufficient in some areas and needlessly in-depth in others, you are likely to be rebutted with quotes from the syllabus and course catalogue. When you try to talk about industry requirements, they will counter by pointing out prerequisites.</p>

<p>I think all students, no matter what their field of study is, would be wise to cultivate relationships with people working in the industries they hope to find their own place in. I wonder how many computer science students actually ask someone who codes for a living, What skills do you use the most at work? or even What did they ask you when you interviewed for the job? The best thing you can do is seek out a mentor who is doing the kind of job you some day hope to do.<br />
</p>
  <span class="comments-post" style="margin-left:20px">Lord_humungus on January 14, 2008 12:36 PM</span> 
  </div>

  <div class="comments-body thomas"> 
  <p>It is useless to teach the very practical aspects of software engineering, e.g. &quot;Visual Studio 2005&quot; or &quot;Windows API&quot;, in university, because these things are outdated by the time students get into a real job.</p>

<p>For example, I took a course on GPU programming two years ago, and although the basic concepts haven&#39;t changed, pretty much everything else has.</p>

<p>Therefore, universities should focus on the fundamental concepts, not on the implementations thereof. Which is exactly what they do.</p>
  <span class="comments-post" style="margin-left:20px">Thomas on January 14, 2008 12:58 PM</span> 
  </div>
	


	
<p>





<a href="http://www.codinghorror.com/blog/2008/01/how-should-we-teach-computer-science/comments/page/2/#comments"><span class="pager-label">More comments</span><span class="chevron">&#187;</span></a>

</p>



<div id="endcomments"></div> 



	<p class="comments-closed">
		The comments to this entry are closed.
	</p>



</div> <!-- blog -->

<div id="footer">Content &copy; 2012 <a rel="author" href="https://profiles.google.com/codinghorror1">Jeff Atwood</a>.  Logo image used with permission of the author. &copy; 1993 Steven C. McConnell. All Rights Reserved.</div>  

</div> <!-- container -->

<div id="links"> 


<div class="side">
<div class="sidetitle">Newer &raquo;</div>
<a href="http://www.codinghorror.com/blog/2008/01/whats-on-your-keychain-2008-edition.html">What's On Your Keychain, 2008 Edition</a>
</div>



<div class="side">
<div class="sidetitle" style="padding-top:5px">&laquo; Older</div>
<a href="http://www.codinghorror.com/blog/2008/01/the-enduring-art-of-computer-programming.html">The Enduring Art of Computer Programming</a>
</div> 

 
<p></p> 

<div class="side"> 
<!-- 

<a href="http://www.codinghorror.com/blog/">Home</a> &nbsp; &nbsp; <a href="http://www.codinghorror.com/blog/archives.html">Browse All Posts</a> 
<p></p> 

-->

<div id="influads_block" class="influads_block" style="width:208px !important; align:center;"> </div>

<script async>
(function(){var acc='acc_843d584_pub';var st='css';var or='130';var e=document.getElementsByTagName('script')[0];var d=document.createElement('script');d.src=('https:' == document.location.protocol ?'https://' : 'http://') +'engine.influads.com/show/'+or+'/'+st+'/'+acc;d.type='text/javascript';d.async=true;d.defer=true; e.parentNode.insertBefore(d,e);})();
</script>

<div>
<a href="http://www.atlassian.com/software/ondemand/overview?utm_source=coding-horror&utm_medium=banner&utm_content=ondemand-en-208x250-devsuite-orange-0912&utm_campaign=direct-display" rel="nofollow"><img alt="Atlassian OnDemand Dev Suite in the Cloud, from $10 / month" title="Atlassian OnDemand Dev Suite in the Cloud, from $10 / month" src="http://www.codinghorror.com/.a/6a0120a85dcdae970b017c3243ab99970b-pi" width="208" height="250" /></a>
</div>

<div id="hireme" class="hireme codinghorror" style="min-height:220px"></div>

<script async>
    setTimeout(function () {
        var a = document.createElement("script");
        var b = document.getElementsByTagName('script')[0];
        a.src = "http://careers.stackoverflow.com/ad/js";
        a.async = true; 
        a.type = "text/javascript"; 
        b.parentNode.insertBefore(a, b);
    }, 5);
</script>

<p></p> 
<div class="sidetitle">Resources</div> 
<a href="/blog/2004/02/about-me.html">About Me</a><br/>
<a href="http://twitter.com/codinghorror">@codinghorror</a><br/>
<a href="http://stackexchange.com">stackexchange.com</a><br/>
<a href="/blog/2004/02/recommended-reading-for-developers.html">Recommended Reading</a>
<p></p>
<div class="syndicate"> 
<a href="http://feeds.feedburner.com/codinghorror" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon16x16.png" width=16 height=16 alt="" style="vertical-align:middle;border:0"/>&nbsp;Subscribe in a reader</a> 
<br/> 
<a href="http://feedburner.google.com/fb/a/mailverify?uri=codinghorror&amp;loc=en_US"><img src="/blog/images/mail.png" width=16 height=16 alt="" style="vertical-align:middle;border:0"/>&nbsp;Subscribe via email</a> 
<p></p>
<div class="side"> 
Coding Horror has been continuously published since 2004. Browse the <b><a href="http://www.codinghorror.com/blog/archives.html">complete post archives</a></b>.
</div> 
<p></p> 
<table style="border-spacing:0px">
<tr>
<td style="padding-right:10px">
<img src="http://feeds.feedburner.com/~fc/codinghorror?bg=EEEEEE&amp;fg=111111&amp;anim=0" height="26" width="88" style="border:0" alt="Count of RSS readers" /> 
</td>
<td style="padding-bottom:8px">
<a href="http://my.statcounter.com/project/standard/stats.php?project_id=2600027&amp;guest=1">Traffic Stats</a> 
</td>
</tr>
</table>
</div> 


</div>

</div> <!-- links -->
 
<script> 
x=window.document.getElementsByTagName('div'); for(var i = 0; i < x.length; i++) { if (x[i].className == "comments-body") { if (x[i].innerHTML.search(/jeff atwood<\/a>/i) != -1) { x[i].style.backgroundColor = "#FFECC7"; } } }
</script>

<script>
var sc_project=2600027; 
var sc_invisible=0; 
var sc_partition=25; 
var sc_security="dcff5548"; 
</script> 
 
<script async src="http://www.statcounter.com/counter/counter.js"></script> 
<noscript><a href="http://www.statcounter.com/"><img  src="http://c26.statcounter.com/counter.php?sc_project=2600027&amp;java=0&amp;security=dcff5548&amp;invisible=0" alt="web metrics"></a> </noscript> 



 

<!-- Blogside Toolbar -->
<script type="text/javascript">
    var TPToolbar = {
        src:   "http://www.typepad.com/services/toolbar?blog_id=6a0120a85dcdae970b0128776faab5970c&asset_id=6a0120a85dcdae970b0120a86dbc04970b&atype=Individual&to=http%3A%2F%2Fwww.codinghorror.com%2Fblog%2F2008%2F01%2Fhow-should-we-teach-computer-science.html&autofollowed=0",
        asset_xid: "6a0120a85dcdae970b0120a86dbc04970b",
    
        bookmarklet_uri: "http://static.typepad.com/.shared/js/qp/loader-combined-min.js"
    };
    var TYPEPAD___bookmarklet_domain = "http://www.typepad.com/";
</script>
<script type="text/javascript" src="/.shared/js/toolbar/blogside-toolbar-combined-min.js"></script>
<!-- End Blogside Toolbar -->
<!-- Begin comScore Tag -->
<script>
document.write(unescape("%3Cscript src='" + (document.location.protocol == "https:" ? "https://sb" : "http://b") + ".scorecardresearch.com/beacon.js'%3E%3C/script%3E"));
</script>
<script>
COMSCORE.beacon({
  c1: 2,
  c2: "6035669",
  c3: "",
  c4: "http://www.codinghorror.com/blog/2008/01/how-should-we-teach-computer-science.html",
  c5: "",
  c6: "",
  c15: ""
});
</script>
<noscript>
  <img src="http://b.scorecardresearch.com/b?c1=2&c2=6035669&c3=&c4=http%3A%2F%2Fwww.codinghorror.com%2Fblog%2F2008%2F01%2Fhow-should-we-teach-computer-science.html&c5=&c6=&c15=&cv=1.3&cj=1" style="display:none" width="0" height="0" alt="" />
</noscript>
<!-- End comScore Tag -->
<!-- ph=1 -->
